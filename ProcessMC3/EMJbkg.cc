#include <iostream>
#include <iomanip>
#include <locale>

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>

#include "vector"
using std::vector;
#include "algorithm"

#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include "EMJselect.h"
#include "EMJ16003.h"
#include "QCDhists.h"
#include "EMJbkg.h"

float pilecut=5000.;
float pilecut2=1.5;
float ipXYsigcut=2.0;

float DeltaR(float eta1, float phi1, float eta2, float phi2) {

    float dR=0.;
    float deta = std::fabs(eta1-eta2);
    float dphi = std::fabs(phi1-phi2);
    if(dphi>3.14159) dphi = 2.*3.14159-dphi;
    dR=std::sqrt(deta*deta+dphi*dphi);

    return dR;
}

int EMJbkg(bool otfile, bool hasPre, const char* inputfilename,const char* outputfilename,
           float HTcut, float pt1cut, float pt2cut, float pt3cut, float pt4cut, float jetacut,float alphaMaxcut, float maxIPcut, float NemfracCut,float CemfracCut,int ntrk1cut, int NemergingCut,bool blind) {
    // "ntuple.root", "histos.root"
    // suggest cuts 1000., 400.,200.,125.,50.,0.2,0.9,0.9,0,1
    // right now this code hard wires the jet pT cut and requires emerging jets to have at least
    // one track with pT> 1 GeV

    // read the Tree generated by tree1w and fill two histograms
    // note that we use "new" to create the TFile and TTree objects,
    // to keep them alive after leaving this function.
 
    int npass=0;

    TFile *f = new TFile(inputfilename);
    if(f->IsZombie()) {
        std::cout << "File: " << inputfilename << " does not exist." << std::endl;
        return 0;
    }

    // get histogram of events before trigger
    TH1F *eventCountPreTrigger;

    if(hasPre) {
        if(otfile) eventCountPreTrigger = static_cast<TH1F*>(f->Get("eventCountPreTrigger/eventCountPreTrigger")->Clone());
    } else {
        if(otfile)  eventCountPreTrigger = new TH1F("eventCountPreTrigger","haha",2,0.,2.);
    }



    TTree *tt = (TTree*)f->Get("emJetAnalyzer/emJetTree");

    Int_t nVtx, event, lumi, run, nTrueInt, nTracks, pv_indexInColl;
    Float_t met_pt, met_phi;//, pv_index;
    bool hltTrig1n, hltTrig1d, hltTrig2n, hltTrig2d, hltTrig3n, hltTrig3d;
    float pv_z;

    vector<int> *jet_index=0;
    vector<int> *jet_source=0;
    vector<float> *jet_pt = 0;
    vector<float> *jet_eta = 0;
    vector<float> *jet_phi = 0;
    vector<float> *jet_alphaMax = 0;
    vector<float> *jet_cef = 0;
    vector<float> *jet_nef = 0;
    vector<float> *jet_chf = 0;
    vector<float> *jet_nhf = 0;
    vector<float> *jet_theta2D = 0;
    //  vector<float> *jet_phf = 0;
    vector<vector<float> > *track_pt = 0;
    vector<vector<float> > *track_eta = 0;
    vector<vector<int> > *track_source = 0;
    vector<vector<int> > *track_index = 0;
    vector<vector<int> > *track_jet_index = 0;
    vector<vector<int> > *track_vertex_index = 0;
    vector<vector<int> > *track_algo = 0;
    vector<vector<int> > *track_quality = 0;
    vector<vector<float> > *track_vertex_weight =0;
    vector<vector<float> > *track_pvWeight = 0;
    vector<vector<float> > *track_ipZ =0;
    vector<vector<float> > *track_ipXY = 0;
    vector<vector<float> > *track_ipXYSig = 0;
    vector<vector<float> > *track_ref_z =0;//analysis_20170523_v0
    vector<vector<int> > *track_nMissInnerHits = 0;
    vector<vector<int> > *track_nMissInnerPxlLayers = 0;
    vector<vector<int> > *track_nPxlLayers = 0;
    vector<vector<int> > *track_nHits = 0;

    /*
      vector<int> *vertex_index=0;
      vector<int> *vertex_source=0;
      vector<float> *vertex_z =0;
    */

    // gen particles
    vector<int> *gp_index = new vector<int>;
    vector<int> *gp_pdgId = new vector<int>;
    vector<float> *gp_pt = new vector<float>;
    vector<float> *gp_eta = new vector<float>;
    vector<float> *gp_phi = new vector<float>;
    vector<int> *gp_charge = new vector<int>;
    vector<int> *gp_status = new vector<int>;
    vector<float> *gp_vx = new vector<float>;
    vector<float> *gp_vy = new vector<float>;
    vector<float> *gp_vz = new vector<float>;
    //get event count pre trigger


    // gen particles
    tt->SetBranchAddress("gp_index",&gp_index);
    tt->SetBranchAddress("gp_pdgId",&gp_pdgId);
    tt->SetBranchAddress("gp_pt",&gp_pt);
    tt->SetBranchAddress("gp_eta",&gp_eta);
    tt->SetBranchAddress("gp_phi",&gp_phi);
    tt->SetBranchAddress("gp_charge",&gp_charge);
    tt->SetBranchAddress("gp_status",&gp_status);
    tt->SetBranchAddress("gp_vx",&gp_vx);
    tt->SetBranchAddress("gp_vy",&gp_vy);
    tt->SetBranchAddress("gp_vz",&gp_vz);

    //for ntuple
    tt->SetBranchAddress("pv_indexInColl",&pv_indexInColl);
    tt->SetBranchAddress("pv_z",&pv_z);
    //tt->SetBranchAddress("pv_index",&pv_index);
    tt->SetBranchAddress("nVtx",&nVtx);
    tt->SetBranchAddress("nTrueInt",&nTrueInt);
    tt->SetBranchAddress("nTracks",&nTracks);
    tt->SetBranchAddress("event",&event);
    tt->SetBranchAddress("lumi",&lumi);
    tt->SetBranchAddress("run",&run);
    tt->SetBranchAddress("met_pt",&met_pt);
    tt->SetBranchAddress("met_phi",&met_phi);
    tt->SetBranchAddress("jet_index",&jet_index);
    tt->SetBranchAddress("jet_source",&jet_source);
    //tt->SetBranchAddress("jet_ptRaw",&jet_pt);//analysis_20170523_v0
    tt->SetBranchAddress("jet_pt",&jet_pt);
    tt->SetBranchAddress("jet_eta",&jet_eta);
    tt->SetBranchAddress("jet_phi",&jet_phi);
    tt->SetBranchAddress("jet_cef",&jet_cef);
    tt->SetBranchAddress("jet_nef",&jet_nef);
    tt->SetBranchAddress("jet_chf",&jet_chf);
    tt->SetBranchAddress("jet_nhf",&jet_nhf);
    tt->SetBranchAddress("jet_theta2D",&jet_theta2D);//median of assoc. trk. theta2Ds.
    //  tt->SetBranchAddress("jet_phf",&jet_phf);
    tt->SetBranchAddress("jet_alphaMax",&jet_alphaMax);
    tt->SetBranchAddress("track_pt",&track_pt);
    tt->SetBranchAddress("track_eta",&track_eta);
    tt->SetBranchAddress("track_source",&track_source);
    tt->SetBranchAddress("track_index",&track_index);
    tt->SetBranchAddress("track_jet_index",&track_jet_index);
    tt->SetBranchAddress("track_algo",&track_algo);
    tt->SetBranchAddress("track_quality",&track_quality);
    tt->SetBranchAddress("track_vertex_index",&track_vertex_index);
    tt->SetBranchAddress("track_vertex_weight",&track_vertex_weight);
    tt->SetBranchAddress("track_pvWeight",&track_pvWeight);
    tt->SetBranchAddress("track_ipXY",&track_ipXY);
    tt->SetBranchAddress("track_ipXYSig",&track_ipXYSig);
    tt->SetBranchAddress("track_ref_z",&track_ref_z);//analysis_20170523_v0
    tt->SetBranchAddress("track_nMissInnerHits",&track_nMissInnerHits);
    tt->SetBranchAddress("track_nMissInnerPxlLayers",&track_nMissInnerPxlLayers);
    tt->SetBranchAddress("track_nPxlLayers",&track_nPxlLayers);
    tt->SetBranchAddress("track_nHits",&track_nHits);
    tt->SetBranchAddress("track_ipZ",&track_ipZ);
    tt->SetBranchAddress("HLT_HT400",&hltTrig1d);
    tt->SetBranchAddress("HLT_HT500",&hltTrig1n);
    tt->SetBranchAddress("HLT_HT250",&hltTrig2d);
    tt->SetBranchAddress("HLT_HT350",&hltTrig2n);
    tt->SetBranchAddress("HLT_PFHT600",&hltTrig3d);
    tt->SetBranchAddress("HLT_PFHT800",&hltTrig3n);//76, 80
    //tt->SetBranchAddress("HLT_PFHT900",&hltTrig3n);//74

    /*
      tt->SetBranchAddress("vertex_index",&vertex_index);
      tt->SetBranchAddress("vertex_source",&vertex_source);
      tt->SetBranchAddress("vertex_z",&vertex_z);
    */

    // create a histograms
    TH1F *acount,*count,*hjetcut,*hjetchf,*h_nemg,*h_nemgSR,*h_nemgFR,*h_nalemg,*hnjet,*hnjetSR,*hnjetFR,*hpt,*heta,*heta2,*hetaaSR,*hetaaFR,*halpha,*halphaZero,*H_T,*H_T0,*H_T1,*H_T2,*H_T3,*H_T4,*H_TFR,*hbcut_ntrkpt1,*hacut_ntrkpt1,*hbcut_nef,*hacut_nef,*hbcut_cef,*hacut_cef,*hbcut_alphamax,*hacut_alphamax,*hHTnm1,*hnHitsnm1,*hntrk1nm1,*hmaxipnm1,*hpt1nm1,*hpt2nm1,*hpt3nm1,*hpt4nm1,*halphanm1,*hnemnm1,*hpt1,*hpt2,*hpt3,*hpt4,*hipXYEJ,*hipXYnEJ,*htvw,*htvwEJ,*hnmaxipnm1,*hn2maxipnm1,*hjptfrb,*hjptfra1,*hjptfra2,*hjptfrbc,*hjptfra1c,*hjptfra2c,*hjptb,*hjpta,*hjptaSR,*hjptaFR,*haMgj,*hHTko,*hpt1ko,*hpt2ko,*hpt3ko,*hpt4ko,*hipXYSigEJ,*hipXYSignEJ,*hmaxipXYEJ,*hmaxipXYnEJ,*hmeanipXYEJ,*hmeanipXYnEJ,*hmass,*hmassFR,*hmedipXYEJ,*hmedipXYnEJ,*hmeanipXYSigEJ,*hmeanipXYSignEJ,*hmedipXYSigEJ,*hmedipXYSignEJ,*hlogmeanipXYSigEJ,*hlogmeanipXYSignEJ,*hlogmedipXYSigEJ,*hlogmedipXYSignEJ,*hTrig1d,*hTrig1n,*hTrig2d,*hTrig2n,*hTrig3d,*hTrig3n,*hmedtheta2DEJ,*hmedtheta2DnEJ,*hlogmedtheta2DEJ,*hlogmedtheta2DnEJ,*hfrwgt,*hntrkSR,*hntrkFR;

    // discriminating variables after pre-selection (4jets)
    TH1F *halphaPS,*halphaZeroPS,*hmedtheta2DPS,*hlogmedtheta2DPS,*hmedipXYSigPS,*hlogmedipXYSigPS;
    // final selection
    TH1F *hmedtheta2DSR,*hlogmedtheta2DSR,*hmedipXYSigSR,*hlogmedipXYSigSR;

    // Fake background
    TH1F *hmedtheta2DFR,*hlogmedtheta2DFR,*hmedipXYSigFR,*hlogmedipXYSigFR;

    TH2F *aMip,*haMvjpt,*haMvHT,*haMvnvtx;

    // discriminating variables no selection
    TH2F *halphavtheta2D,*halphavipXYSig,*htheta2DvipXYSig;
    // discriminating variables after pre-selection (4jets)
    TH2F *halphavtheta2DPS,*halphavipXYSigPS,*htheta2DvipXYSigPS;
    // final selection
    TH2F *htheta2DvipXYSigSR;
    // Fake background
    TH2F *htheta2DvipXYSigFR;

    if(otfile) {
        TH1::SetDefaultSumw2();

        acount = new TH1F("acount","counts",20,0.,20.);
        count = new TH1F("count","counts",3,0,3);
        count->SetStats(0);
        count->SetCanExtend(TH1::kAllAxes);
        count->Fill("All",0);
        count->Fill("HLT",0);
        count->Fill("4 jets",0);
        count->Fill("HT",0);
        count->Fill("jet pt1",0);
        count->Fill("jet pt2",0);
        count->Fill("jet pt3",0);
        count->Fill("jet pt4",0);
        count->Fill("emerging",0);
        count->Fill("almostemerging",0);
        count->Fill("FakeRateBKG",0);

        // 1d
        //hfrwgt = new TH1F("hfrwgt","fake bkg. wgt.",1000,0.,0.002);//Ntag>=2
        hfrwgt = new TH1F("hfrwgt","fake bkg. wgt.",1000,0.,0.5);//Ntag==1 or >=1
        hjetcut = new TH1F("hjetcut","jetcut counts",20,0.,20.);
        hjetchf = new TH1F("hjetchf","jet charged hadron fr",20,0.,1.2);
        h_nemg = new TH1F("h_nemg","number of emerging jets",20,0.,20.);
        h_nemgSR = new TH1F("h_nemgSR","number of emerging jets (SR)",20,0.,20.);
        h_nemgFR = new TH1F("h_nemgFR","number of emerging jets (FR)",20,0.,20.);
        h_nalemg = new TH1F("h_nalemg","number of almostemerging jets",20,0.,20.);
        hnjet = new TH1F("hnjet","number of jets",20,0.,20.);
        hnjetSR = new TH1F("hnjetSR","number of jets (SR)",20,0.,20.);
        hnjetFR = new TH1F("hnjetFR","number of jets (FR)",20,0.,20.);
        hpt = new TH1F("hpt","jet pt distribution",200,0.,1000.);
        heta   = new TH1F("heta","jet eta distribution",100,-4.,4.);
        heta2   = new TH1F("heta2","jet eta distribution first 4 jets",100,-4.,4.);
        hetaaSR = new TH1F("hetaaSR","emerging jet eta distribution (SR)",100,-4.,4.);
        hetaaFR = new TH1F("hetaaFR","emerging jet eta distribution (FR)",100,-4.,4.);
        halpha   = new TH1F("halpha","jet alpha distribution",1000,0.,1.0);
        halphaZero   = new TH1F("halphaZero","jet alpha==0 distribution",1000,-0.1,0.1);
        haMgj   = new TH1F("haMgj","jet alphaMax distribution, good jets",1000,0.,1.0);
        H_T      = new TH1F("H_T"," HT distribution before cut", 100,0.,5000.);
        H_T0      = new TH1F("H_T0"," HT distribution after HLT cut", 100,0.,5000.);
        H_T1      = new TH1F("H_T1"," HT distribution after 4jets cut", 100,0.,5000.);
        H_T2      = new TH1F("H_T2"," HT distribution after HT cut", 100,0.,5000.);
        H_T3      = new TH1F("H_T3"," HT distribution at end (SR)", 100,0.,5000.);
        H_T4      = new TH1F("H_T4"," HT distribution test", 100,0.,5000.);
        H_TFR     = new TH1F("H_TFR"," HT distribution at end (FR)", 100,0.,5000.);
        hpt1 = new TH1F("hpt1"," pT of leading jet",200,0.,1000.);
        hpt2 = new TH1F("hpt2"," pT of second jet",200,0.,1000.);
        hpt3 = new TH1F("hpt3"," pT of third jet",200,0.,1000.);
        hpt4 = new TH1F("hpt4"," pT of fourth jet",200,0.,1000.);
        hbcut_ntrkpt1 = new TH1F("hbcut_ntrkpt1","number tracks pt>1 before cut",20,0.,20.);
        hacut_ntrkpt1 = new TH1F("hacut_ntrkpt1","number tracks pt>1 after cut",20,0.,20.);
        hbcut_nef = new TH1F("hbcut_nef","neutral em fraction before cut",10,0.,1.2);
        hacut_nef = new TH1F("hacut_nef","neutral em fraction after cut",10,0.,1.2);
        hbcut_cef = new TH1F("hbcut_cef","charged em fraction before cut",50,0.,1.2);
        hacut_cef = new TH1F("hacut_cef","charged em fraction after cut",50,0.,1.2);
        hbcut_alphamax = new TH1F("hbcut_alphamax","alphamax before cut",1000,0.,1.0);
        hacut_alphamax = new TH1F("hacut_alphamax","alphamax after cut",1000,0.,1.0);
        hHTnm1 = new TH1F("hHTnm1","HT n-1",100,0.,5000.);
        hpt1nm1 = new TH1F("hpt1nm1","pt1 n-1",200,0.,1000.);
        hpt2nm1 = new TH1F("hpt2nm1","pt2 n-1",200,0.,1000.);
        hpt3nm1 = new TH1F("hpt3nm1","pt3 n-1",200,0.,1000.);
        hpt4nm1 = new TH1F("hpt4nm1","pt4 n-1",200,0.,1000.);
        halphanm1 = new TH1F("halphanm1","alpha max n-1",1000,0.,1.0);
        hmaxipnm1 = new TH1F("hmaxipnm1","ip max n-1",200,0.,10.);
        hnmaxipnm1 = new TH1F("hnmaxipnm1","new 2 ip max n-1",200,0.,10.);
        hn2maxipnm1 = new TH1F("hn2maxipnm1","new 1  ip max n-1",200,0.,10.);
        hnHitsnm1 = new TH1F("hnHitsnm1","number Hits n-1",40,0.,40.);
        hntrk1nm1 = new TH1F("hntrk1nm1","number tracks pt>1 n-1",50,0.,50.);
        hntrkSR = new TH1F("hntrkSR","number tracks pt>1 (SR)",50,0.,50.);
        hntrkFR = new TH1F("hntrkFR","number tracks pt>1 (FR)",50,0.,50.);
        hnemnm1 = new TH1F("hnemnm1","N emerging jets n-1",10,0.,10.);
        hipXYEJ = new TH1F("hipXYEJ","impact parameter  tracks of emerging jets",300,-1.,1.);
        hipXYnEJ = new TH1F("hipXYnEJ","impact parameter  tracks of not emerging jets",300,-1.,1.);
        htvw = new TH1F("htvw","track vertex weight ",200,-1.,1.);
        htvwEJ= new TH1F("htvwEJ","track vertex weight Emerging Jets ",200,-1.,1.);
        hipXYSigEJ = new TH1F("hipXYSigEJ","ip sig emerging jets",100,0.,10.);
        hipXYSignEJ = new TH1F("hipXYSignEJ","ip sig not emerging jets",100,0.,10.);
        hmaxipXYEJ = new TH1F("hmaxipXYEJ","max ip emerging jets",1000,0.,10.);
        hmaxipXYnEJ = new TH1F("hmaxipXYnEJ","max ip not emerging jets",1000,0.,10.);
        hmeanipXYEJ = new TH1F("hmeanipXYEJ","mean ip emerging jets",1000,0.,2.);
        hmeanipXYnEJ = new TH1F("hmeanipXYnEJ","mean ip not emerging jets",1000,0.,2.);
        hmedipXYEJ = new TH1F("hmedipXYEJ","median ip emerging jets",1000,0.,2.);
        hmedipXYnEJ = new TH1F("hmedipXYnEJ","median ip not emerging jets",1000,0.,2.);
        hmeanipXYSigEJ = new TH1F("hmeanipXYSigEJ","mean ip_{sig} emerging jets",1000,0.,100.);
        hmeanipXYSignEJ = new TH1F("hmeanipXYSignEJ","mean ip_{sig} not emerging jets",1000,0.,100.);
        hmedipXYSigEJ = new TH1F("hmedipXYSigEJ","median ip_{sig} emerging jets",1000,0.,100.);
        hmedipXYSignEJ = new TH1F("hmedipXYSignEJ","median ip_{sig} not emerging jets",1000,0.,100.);
        hmedtheta2DEJ = new TH1F("hmedtheta2DEJ","median #hat{#Theta_{2D}} emerging jets",200,0.,0.4);
        hmedtheta2DnEJ = new TH1F("hmedtheta2DnEJ","median #hat{#Theta_{2D}} not emerging jets",200,0.,0.4);
        hlogmeanipXYSigEJ = new TH1F("hlogmeanipXYSigEJ","mean log_{10} ip_{sig} emerging jets",1000,-1.,4.);
        hlogmeanipXYSignEJ = new TH1F("hlogmeanipXYSignEJ","mean log_{10} ip_{sig} not emerging jets",1000,-1.,4.);
        hlogmedipXYSigEJ = new TH1F("hlogmedipXYSigEJ","median log_{10} ip_{sig} emerging jets",1000,-1.,4.);
        hlogmedipXYSignEJ = new TH1F("hlogmedipXYSignEJ","median log_{10} ip_{sig} not emerging jets",1000,-1.,4.);
        hlogmedtheta2DEJ = new TH1F("hlogmedtheta2DEJ","median log_{10} #hat{#Theta_{2D}} emerging jets",1000,-3.5,0.5);
        hlogmedtheta2DnEJ = new TH1F("hlogmedtheta2DnEJ","median log_{10} #hat{#Theta_{2D}} not emerging jets",1000,-3.5,0.5);
        hjptb = new TH1F("hjptb"," pT of basic jet",100,0.,1000.);
        hjpta = new TH1F("hjpta"," pT of emergng jets",100,0.,1000.);
        hjptaSR = new TH1F("hjptaSR"," pT of emergng jets (SR)",100,0.,1000.);
        hjptaFR = new TH1F("hjptaFR"," pT of emergng jets (FR)",100,0.,1000.);
        hjptfrb = new TH1F("hjptfrb"," pT of basic jets passing kine selection and n<4",100,0.,1000.);
        hjptfra1 = new TH1F("hjptfra1"," pT of basic jets passing kine, almost selection and n<4",100,0.,1000.);
        hjptfra2 = new TH1F("hjptfra2"," pT of basic jets passing kine, almost, and emerging selection and n<4",100,0.,1000.);
        hjptfrbc = new TH1F("hjptfrbc"," pT of basic jets passing kine selection",100,0.,1000.);
        hjptfra1c = new TH1F("hjptfra1c"," pT of basic jets passing kine, almost selection",100,0.,1000.);
        hjptfra2c = new TH1F("hjptfra2c"," pT of basic jets passing kine, almost, and emerging selection",100,0.,1000.);
        hHTko      = new TH1F("hHTko"," HT distribution test kine cuts", 100,0.,5000.);
        hpt1ko = new TH1F("hpt1ko"," pT of leading jet kine cuts",200,0.,1000.);
        hpt2ko = new TH1F("hpt2ko"," pT of second jet kine cuts",200,0.,1000.);
        hpt3ko = new TH1F("hpt3ko"," pT of third jet kine cuts",200,0.,1000.);
        hpt4ko = new TH1F("hpt4ko"," pT of fourth jet kine cuts",200,0.,1000.);
        hmass = new TH1F("hmass","mass emerging and non pairs (SR)",500,0.,5000.);
        hmassFR = new TH1F("hmassFR","mass emerging and non pairs (FR)",500,0.,5000.);

        // plots after pre sel (Cpt4)
        halphaPS = new TH1F("halphaPS","jet alpha distribution (pre. sel.)",1000,0.,1.0);
        halphaZeroPS = new TH1F("halphaZeroPS","jet alpha==0 distribution (pre. sel.)",1000,-0.1,0.1);
        hmedipXYSigPS = new TH1F("hmedipXYSigPS","median ip_{sig} emerging jets (pre. sel.)",1000,0.,100.);
        hmedtheta2DPS = new TH1F("hmedtheta2DPS","median #hat{#Theta_{2D}} emerging jets (pre. sel.)",200,0.,0.4);
        hlogmedipXYSigPS = new TH1F("hlogmedipXYSigPS","median log_{10} ip_{sig} emerging jets (pre. sel.)",1000,-1.,4.);
        hlogmedtheta2DPS = new TH1F("hlogmedtheta2DPS","median log_{10} #hat{#Theta_{2D}} emerging jets (pre. sel.)",1000,-3.5,0.5);

        hmedipXYSigSR = new TH1F("hmedipXYSigSR","median ip_{sig} emerging jets (SR)",1000,0.,100.);
        hmedtheta2DSR = new TH1F("hmedtheta2DSR","median #hat{#Theta_{2D}} emerging jets (SR)",200,0.,0.4);
        hlogmedipXYSigSR = new TH1F("hlogmedipXYSigSR","median log_{10} ip_{sig} emerging jets (SR)",1000,-1.,4.);
        hlogmedtheta2DSR = new TH1F("hlogmedtheta2DSR","median log_{10} #hat{#Theta_{2D}} emerging jets (SR)",1000,-3.5,0.5);

        hmedipXYSigFR = new TH1F("hmedipXYSigFR","median ip_{sig} emerging jets (FR)",1000,0.,100.);
        hmedtheta2DFR = new TH1F("hmedtheta2DFR","median #hat{#Theta_{2D}} emerging jets (FR)",200,0.,0.4);
        hlogmedipXYSigFR = new TH1F("hlogmedipXYSigFR","median log_{10} ip_{sig} emerging jets (FR)",1000,-1.,4.);
        hlogmedtheta2DFR = new TH1F("hlogmedtheta2DFR","median log_{10} #hat{#Theta_{2D}} emerging jets (FR)",1000,-3.5,0.5);

        // HLT
        hTrig1d = new TH1F("hTrig1d","HLT_HT400_DispDijet40_Incl",150,0.,1500.);
        hTrig1n = new TH1F("hTrig1n","HLT_HT500_DispDijet40_Incl",150,0.,1500.);
        hTrig2d = new TH1F("hTrig2d","HLT_HT250_DispDijet40_DispTrack",150,0.,1500.);
        hTrig2n = new TH1F("hTrig2n","HLT_HT350_DispDijet40_DispTrack",150,0.,1500.);
        hTrig3d = new TH1F("hTrig3d","HLT_PFHT600",200,0.,2000.);
        hTrig3n = new TH1F("hTrig3n","HLT_PFHT800",200,0.,2000.);//76, 80
        //hTrig3n = new TH1F("hTrig3n","HLT_PFHT900",200,0.,2000.);//74

        //2d
        aMip = new TH2F("aMip"," alpha Max vs. max IP n-1 plot",100,0.,1.,100,0.,10.);
        haMvjpt = new TH2F("haMvjpt"," alpha Max vs. jet pT ",100,0.,1.,100,0.,700.);
        haMvHT = new TH2F("haMvHT"," alpha Max vs. HT ",100,0.,1.,100,0.,2500.);
        haMvnvtx = new TH2F("haMvnvtx"," alpha Max vs. nvtx ",40,0.,1.,100,0.,40.);

        halphavtheta2D = new TH2F("halphavtheta2D"," alpha Max vs. #hat{#Theta}_{2D} plot",100,0.,1.,100,0.,0.4);
        halphavipXYSig = new TH2F("halphavipXYSig"," alpha Max vs. #hat{IP}^{2D}_{Sig} plot",100,0.,1.,100,0.,10.0);
        htheta2DvipXYSig = new TH2F("htheta2DvipXYSig"," #hat{#Theta}_{2D} vs. #hat{IP}^{2D}_{Sig} plot",100,0.,0.4,100,0.,10.0);

        halphavtheta2DPS = new TH2F("halphavtheta2DPS"," alpha Max vs. #hat{#Theta}_{2D} plot (pre. sel.)",100,0.,1.,100,0.,0.4);
        halphavipXYSigPS = new TH2F("halphavipXYSigPS"," alpha Max vs. #hat{IP}^{2D}_{Sig} plot (pre. sel.)",100,0.,1.,100,0.,10.0);
        htheta2DvipXYSigPS = new TH2F("htheta2DvipXYSigPS"," #hat{#Theta}_{2D} vs. #hat{IP}^{2D}_{Sig} plot (pre. sel.)",100,0.,0.4,100,0.,10.0);

        htheta2DvipXYSigSR = new TH2F("htheta2DvipXYSigSR"," #hat{#Theta}_{2D} vs. #hat{IP}^{2D}_{Sig} plot (SR)",100,0.,0.4,100,0.,10.0);
        htheta2DvipXYSigFR = new TH2F("htheta2DvipXYSigFR"," #hat{#Theta}_{2D} vs. #hat{IP}^{2D}_{Sig} plot (FR)",100,0.,0.4,100,0.,10.0);
    }

    //read all entries and fill the histograms
    Int_t nentries = (Int_t)tt->GetEntries();


    double np0 = 0;
    double np1 = 0;
    double np2 = 0;
    double np3 = 0;
    double minJetPt = 100.0;
    const int varType = 2;
    const int ntagType = 2; //0:>=1 tag; 1: ==1 tag; 2: == 2 tag (flav dep); 21: == 2 tag (T&P); 3: == 3 tag; else: >= NemergingCut tag
    // loop over events
    for (Int_t i=0; i<nentries; i++) {
        //std::cout<<"***event "<<event<<std::endl;
 
        if(!hasPre && otfile) eventCountPreTrigger->Fill(1);
    
        if(otfile) count->Fill("All",1);  // count number of events
        if(otfile) acount->Fill(0); // events passing JetFilter
        tt->GetEntry(i);
        //    std::cout<<"event number is "<<event<<" number of vertex is "<<nVtx<<std::endl;

        // make some basic plots on all events before any selections

        if (pv_indexInColl != 0) continue;
        //if (pv_index != 0) continue;
        // PVZ cut
        if(fabs(pv_z)>15) continue;//analysis_20170523_v0

        /*
        //pv;s
        int NNNvertex = (*vertex_index).size();
        std::cout<<"number of vertices is "<<NNNvertex<<std::endl;
        for(Int_t j=0; j<NNNvertex; j++) {
        std::cout<<"vertex source["<<j<<"] is "<<(*vertex_source)[j]<<std::endl;
        std::cout<<"vertex z["<<j<<"] is "<<(*vertex_z)[j]<<std::endl;
        }
        */

        const int NNNjet = jet_index->size();
        // jets
        vector<double> jet_fnonPU(NNNjet);//analysis_20170523_v0
        vector<double> jet_fmaxtrkpt(NNNjet);//analysis_20170523_v0
        vector<double> jet_fsmallIPsig(NNNjet);//analysis_20170523_v0
        vector<int> jet_ntrkpt1(NNNjet);
        vector<float> jet_alpha(NNNjet);
        vector<float> jet_meanip(NNNjet);
        vector<float> jet_meanipsig(NNNjet);
        vector<float> jet_logmeanipsig(NNNjet);
        vector<float> jet_medip(NNNjet);
        vector<float> jet_medipsig(NNNjet);
        vector<float> jet_logmedipsig(NNNjet);
        vector<float> jet_medtheta2D(NNNjet);
        vector<float> jet_logmedtheta2D(NNNjet);
        vector<float> r0(NNNjet);
        vector<float> r0sig(NNNjet);
        vector<float> r1(NNNjet);
        vector<int> jntrack(NNNjet);
        vector<float> jet_e(NNNjet);
        vector<float> jet_theta(NNNjet);
        vector<float> jet_px(NNNjet);
        vector<float> jet_py(NNNjet);
        vector<float> jet_pz(NNNjet);

        vector<int> jet_pid_maxEt(NNNjet);
        vector<float> jet_maxET_part(NNNjet);

        if(otfile) hnjet->Fill(NNNjet);

        for(Int_t j=0; j<NNNjet; j++) {
            //      std::cout<<"jet j = "<<j<<std::endl;
            jet_theta[j]=2.*atan(exp(-jet_eta->at(j)));
            jet_e[j]=jet_pt->at(j)/sin(jet_theta[j]);
            jet_px[j]=jet_pt->at(j)*cos(jet_phi->at(j));
            jet_py[j]=jet_pt->at(j)*sin(jet_phi->at(j));
            jet_pz[j]=jet_pt->at(j)/tan(jet_theta[j]);

            if(otfile) hpt->Fill(jet_pt->at(j));
            if(otfile) heta->Fill(jet_eta->at(j));
            if(otfile) hjetchf->Fill(jet_chf->at(j));
            if(otfile) if(j<4) heta2->Fill(jet_eta->at(j));
            //if(otfile) halpha->Fill(jet_alphaMax->at(j));
            //      calculate  number of tracks with pt > 1
            jet_ntrkpt1[j]=0;
            jet_meanip[j]=-1.;
            jet_logmeanipsig[j]=-1.;
            jet_medip[j]=-1.;
            jet_medipsig[j]=-1.;
            jet_logmedipsig[j]=-1.;
            jet_medtheta2D[j]=-1.;
            jet_logmedtheta2D[j]=-3.5;//xmin of hlogmedtheta2DEJ
            jet_alpha[j]=-1.;
            jet_fnonPU[j]=0.;//analysis_20170523_v0
            jet_fmaxtrkpt[j]=0.;//analysis_20170523_v0
            jet_fsmallIPsig[j]=0.;//analysis_20170523_v0

            if(r0.size()>0) {r0[j]=-1.;r0sig[j]=-1.;}
            if(r1.size()>0) r1[j]=-1.;
            vector<float> track_pts = track_pt->at(j);
            vector<int> track_sources = track_source->at(j);
            vector<int> track_qualitys = track_quality->at(j);
            //vector<float> track_vertex_weights = track_vertex_weight->at(j);
            vector<float> track_pvWeights = track_pvWeight->at(j);
            vector<float> track_ipXYs = track_ipXY->at(j);
            vector<float> track_ipXYSigs = track_ipXYSig->at(j);
            vector<float> sort_ip(track_pts.size());
            vector<float> sort_ipsig(track_pts.size());
            for(uint it=0;it<track_pts.size();it++) sort_ip[it]=0;
            for(uint it=0;it<track_pts.size();it++) sort_ipsig[it]=0;
            vector<float> jet_trkip;
            vector<float> jet_trkipsig;
            vector<float> track_ref_zs = track_ref_z->at(j);//analysis_20170523_v0

            // jet_alpha
            //jet_alpha[j] = GetAlpha(track_pts,track_sources,track_qualitys,track_vertex_weights);//old
            //analysis_20170517_v0
//             if (varType==1) jet_alpha[j] = GetAlpha(track_pts,track_sources,track_qualitys,track_pvWeights);
//             else {
//                 alphaMaxcut = 0.3;
//                 jet_alpha[j] = GetAlpha2Dsig(track_pts,track_sources,track_qualitys,track_ipXYSigs);
//             }
            //analysis_20170523_v0
            if (varType==1) jet_alpha[j] = GetAlpha(track_pts,track_sources,track_qualitys,track_pvWeights,track_ref_zs,pv_z,pilecut2);
            else {
                alphaMaxcut = 0.3;
                jet_alpha[j] = GetAlpha2Dsig(track_pts,track_sources,track_qualitys,track_ipXYSigs,track_ref_zs,pv_z,pilecut2);
            }
            //std::cout << "alphaMax = " << jet_alphaMax->at(j) << "; alpha new = " << jet_alpha[j] << " [here]" << std::endl;
//             if(otfile) {//all jets
//                 halpha->Fill(jet_alpha[j]);
//                 if (jet_alpha[j]==0) halphaZero->Fill(jet_alpha[j]);
//             }

            jntrack[j]=0;
            double sumptallnz=0.;
            double sumnonPU=0.;
            double sumsmallIPsig=0.;
            float ptmaxtrk=0.;

            for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
                if(track_sources[itrack]==0 && ((track_qualitys[itrack] & 4) > 0)) {
                    sumptallnz+=track_pts[itrack];

                    if (fabs(pv_z-track_ref_zs[itrack])>pilecut) continue;// remove tracks with exceedingly large z //analysis_20170523_v0
                    if (fabs(pv_z-track_ref_zs[itrack])<pilecut2) sumnonPU+=track_pts[itrack];//analysis_20170523_v0
                    if (fabs(track_ipXYSigs[itrack])<ipXYsigcut) sumsmallIPsig+=track_pts[itrack];//analysis_20170523_v0

                    if(track_pts[itrack]>ptmaxtrk) {
                        ptmaxtrk=track_pts[itrack];
                    }
                    sort_ip[jntrack[j]]=fabs(track_ipXYs[itrack]);
                    sort_ipsig[jntrack[j]]=fabs(track_ipXYSigs[itrack]);
                    //if(otfile) htvw->Fill(track_vertex_weights[itrack]);
                    if(otfile) htvw->Fill(track_pvWeights[itrack]);
                    //  std::cout<<"track vertex weight is "<<track_vertex_weights[itrack]<<std::endl;
                    if(track_pts[itrack]>1) jet_ntrkpt1[j]+=1;
                    //  std::cout<<" track "<<itrack<<" ip "<<track_ipXYs[itrack]<<" mean ip "<<jet_meanip[j]<<std::endl;
                    jet_meanip[j]=jet_meanip[j]+fabs(track_ipXYs[itrack]);
                    jet_meanipsig[j]=jet_meanipsig[j]+fabs(track_ipXYSigs[itrack]);
                    jet_logmeanipsig[j]=jet_logmeanipsig[j]+fabs(track_ipXYSigs[itrack]);
                    jet_trkip.push_back(fabs(track_ipXYs[itrack]));
                    jet_trkipsig.push_back(fabs(track_ipXYSigs[itrack]));
                    jntrack[j]++;
                }
            }
            float atmp = jntrack[j];
            if(jntrack[j]>0) {
                jet_meanip[j]=jet_meanip[j]/atmp;
                jet_logmeanipsig[j]=jet_logmeanipsig[j]/atmp;
                jet_logmeanipsig[j]=log10(jet_logmeanipsig[j]);

                // median
                jet_medip[j] = CalcMedian(jet_trkip);
                jet_medipsig[j] = CalcMedian(jet_trkipsig);
                jet_logmedipsig[j] = log10(jet_medipsig[j]);
                jet_medtheta2D[j] = jet_theta2D->at(j);
                jet_logmedtheta2D[j] = (jet_medtheta2D[j]==-1 ? -3.5 : log10(jet_theta2D->at(j)));
            }
            if(sumptallnz>0) jet_fnonPU[j]=sumnonPU/sumptallnz;//analysis_20170523_v0
            if(sumnonPU>0) jet_fsmallIPsig[j]=sumsmallIPsig/sumnonPU;//analysis_20170523_v0
            jet_fmaxtrkpt[j]=ptmaxtrk/jet_pt->at(j);//max trk pt/jet pt//analysis_20170523_v0

            std::sort(sort_ip.begin(), sort_ip.end(), std::greater<float>());
            if(sort_ip.size()>0) r0[j]=sort_ip[0];
            if(sort_ip.size()>1) r1[j]=sort_ip[1];
            std::sort(sort_ipsig.begin(), sort_ipsig.end(), std::greater<float>());
            if(sort_ipsig.size()>0) r0sig[j]=sort_ipsig[0];
            //      std::cout<<"mean max are "<<jet_meanip[j]<<" "<<r0[j]<<std::endl;
            if (otfile) {
                halphavtheta2D->Fill(jet_alpha[j],jet_medtheta2D[j]);
                halphavipXYSig->Fill(jet_alpha[j],jet_medipsig[j]);
                htheta2DvipXYSig->Fill(jet_medtheta2D[j],jet_medipsig[j]);
            }


            // calculate some gen particle information for jet
            int NNNgp = gp_index->size();
            int igenmax=-1;
            float etgenmax=0.;
            for(Int_t igen=1; igen<NNNgp; igen++) {
                if((abs(gp_pdgId->at(igen))<6)||(abs(gp_pdgId->at(igen))==21)) {  // quark or gluon
                    if(DeltaR(jet_eta->at(j),jet_phi->at(j),gp_eta->at(igen),gp_phi->at(igen))<0.4) {
                        if(gp_pt->at(igen)>etgenmax) {
                            igenmax=igen;
                            etgenmax=gp_pt->at(igen);
                        }
                    }
                }
            }
            // fix glue to bbbar
            float igenmax2=-1;
            float etgenmax2=0.;
            if(igenmax>0) {
                if(abs(gp_pdgId->at(igenmax))==21) {
                    for(Int_t igen=1; igen<NNNgp; igen++) {
                        if((abs(gp_pdgId->at(igen))==5)&&(gp_pt->at(igen)>10.)) {  // b
                            if(DeltaR(jet_eta->at(j),jet_phi->at(j),gp_eta->at(igen),gp_phi->at(igen))<0.4) {
                                if(gp_pt->at(igen)>etgenmax2) {
                                    igenmax2=1;
                                    etgenmax2=gp_pt->at(igen);
                                }
                            }
                        }
                    }
                }
            }

            jet_pid_maxEt[j]=0;
            jet_maxET_part[j]=0;
            if(igenmax>-1) {
                int ipid = gp_pdgId->at(igenmax);
                if(abs(ipid)<6) {
                    jet_pid_maxEt[j]=gp_pdgId->at(igenmax);
                    jet_maxET_part[j] = etgenmax;
                } else {
                    if(igenmax2==-1) {
                        jet_pid_maxEt[j]=7;
                        jet_maxET_part[j] = etgenmax;
                    } else {//g->bb
                        jet_pid_maxEt[j]=8;
                        jet_maxET_part[j] = etgenmax;

                    }
                }
            } // end calculate some gen particle information for jet

        }  // end of first loop over jets



        //now see which jets are emerging
        //    std::cout<<" in event "<<event<<" number of jets is "<<NNNjet<<std::endl;
        vector<bool> emerging(NNNjet);
        vector<bool> almostemerging(NNNjet);
        vector<bool> basicjet(NNNjet);
        for( int i=0;i<NNNjet;i++) {
            emerging[i]=false;
            almostemerging[i]=false;
            basicjet[i]=false;
        }
        int nemerging=0;
        int nalmostemerging=0;

        for(int ij=0;ij<NNNjet;ij++) {
            vector<int> track_qualitys = track_quality->at(ij);
            vector<float> track_ipXYs = track_ipXY->at(ij);
            vector<float> track_ipXYSigs = track_ipXYSig->at(ij);
            vector<int> track_sources = track_source->at(ij);
            //vector<float> track_vertex_weights = track_vertex_weight->at(ij);
            vector<float> track_pvWeights = track_pvWeight->at(ij);
            vector<float> track_ref_zs = track_ref_z->at(ij);//analysis_20170523_v0
            if(otfile) hjetcut->Fill(0);

            if(fabs(jet_eta->at(ij))<jetacut) { // jet eta cut
                if(otfile) hjetcut->Fill(1);

                if(otfile) hbcut_nef->Fill(jet_nef->at(ij));
                if(jet_nef->at(ij)<NemfracCut) {  // neutral fraction
                    if(otfile) hacut_nef->Fill(jet_nef->at(ij));
                    if(otfile) hjetcut->Fill(2);

                    if(otfile) hbcut_ntrkpt1->Fill(jet_ntrkpt1[ij]);
                    if(jet_ntrkpt1[ij]>ntrk1cut) {  // tracks pt>1
                        if(otfile) hacut_ntrkpt1->Fill(jet_ntrkpt1[ij]);
                        if(otfile) hjetcut->Fill(3);

                        if(otfile) hbcut_cef->Fill(jet_cef->at(ij));
                        if(jet_cef->at(ij)<CemfracCut) {  //charged fraction
                            if(otfile) hacut_cef->Fill(jet_cef->at(ij));
                            if(otfile) hjetcut->Fill(4);
                            if(jet_fmaxtrkpt[ij]>0.6) continue;//analysis_20170523_v0
                            if(otfile) hjetcut->Fill(5);
                            if(jet_fnonPU[ij]<0.4) continue;// analysis_20170523_v0
                            if(otfile) hjetcut->Fill(6);
//                             if(jet_fsmallIPsig[ij]<0.3) continue;// analysis_20170523_v0
//                             if(otfile) hjetcut->Fill(7);

                            basicjet[ij]=true;

                            if(otfile) hbcut_alphamax->Fill(jet_alpha[ij]);
                            if(jet_alpha[ij]<alphaMaxcut && jet_alpha[ij]>-1) { // alpha max
                                if(otfile) hacut_alphamax->Fill(jet_alpha[ij]);
                                if(otfile) hjetcut->Fill(8);
                                almostemerging[ij]=true;

                                // uncomment if count only leading jets for event selection later
                                //if(ij<4)
                                nalmostemerging+=1;
                                /*
                                  if(ij<4) {
                                  std::cout<<" an almost emerging jet "<<ij<<std::endl;
                                  std::cout<<" with r0 of "<<r0[ij]<<std::endl;
                                  std::cout<<" and pt of "<<jet_pt->at(ij)<<std::endl;
                                  }
                                */
                                if(r0[ij]>maxIPcut) { // max IP cut
                                //if(jet_medip[ij]>maxIPcut) { // med IP cut
                                    emerging[ij]=true;

                                    // uncomment if count only leading jets for event selection later
                                    //if(ij<4)
                                    nemerging+=1;
                                    /*
                                      if(ij<4) {
                                      std::cout<<" an emerging jet "<<ij<<std::endl;
                                      std::cout<<" with r0 of "<<r0[ij]<<std::endl;
                                      std::cout<<" and pt of "<<jet_pt->at(ij)<<std::endl;
                                      }
                                    */
                                    // look at tracks in the emerging jets
                                    if(otfile){
                                        hmaxipXYEJ->Fill(r0[ij]);
                                        hmeanipXYEJ->Fill(jet_meanip[ij]);
                                        hmedipXYEJ->Fill(jet_medip[ij]);
                                        hmeanipXYSigEJ->Fill(jet_meanipsig[ij]);
                                        hmedipXYSigEJ->Fill(jet_medipsig[ij]);
                                        hlogmeanipXYSigEJ->Fill(jet_logmeanipsig[ij]);
                                        hlogmedipXYSigEJ->Fill(jet_logmedipsig[ij]);
                                        hmedtheta2DEJ->Fill(jet_medtheta2D[ij]);
                                        hlogmedtheta2DEJ->Fill(jet_logmedtheta2D[ij]);
                                    }
                                    if(jet_meanip[ij]>r0[ij]) std::cout<<"DANGER DANGER"<<std::endl;
                                    for (unsigned itrack=0; itrack<track_ipXYs.size(); itrack++) {
                                        if(track_sources[itrack]==0 && ((track_qualitys[itrack] & 4) > 0)) {
                                            if (fabs(pv_z-track_ref_zs[itrack])>pilecut) continue;//analysis_20170523_v0
                                            if(otfile) hipXYEJ->Fill(track_ipXYs[itrack]);
                                            if(otfile) hipXYSigEJ->Fill(track_ipXYSigs[itrack]);
                                            //if(otfile) htvwEJ->Fill(track_vertex_weights[itrack]);
                                            if(otfile) htvwEJ->Fill(track_pvWeights[itrack]);
                                        }
                                    }
                                }//maxIPcut
                            }//alphaMaxCut
                        }//CemfractCut
                    }//ntrk1cut
                }//NemfracCut
            }//jet eta cut
            if(!emerging[ij]) {
                if(otfile) {
                    hmaxipXYnEJ->Fill(r0[ij]);
                    hmeanipXYnEJ->Fill(jet_meanip[ij]);
                    hmedipXYnEJ->Fill(jet_medip[ij]);
                    hmeanipXYSignEJ->Fill(jet_meanipsig[ij]);
                    hmedipXYSignEJ->Fill(jet_medipsig[ij]);
                    hlogmeanipXYSignEJ->Fill(jet_logmeanipsig[ij]);
                    hlogmedipXYSignEJ->Fill(jet_logmedipsig[ij]);
                    hmedtheta2DnEJ->Fill(jet_medtheta2D[ij]);
                    hlogmedtheta2DnEJ->Fill(jet_logmedtheta2D[ij]);
                }
                for (unsigned itrack=0; itrack<track_ipXYs.size(); itrack++) {
                    if(track_sources[itrack]==0 && ((track_qualitys[itrack] & 4) > 0)) {
                        if (fabs(pv_z-track_ref_zs[itrack])>pilecut) continue;//analysis_20170523_v0
                        if(otfile) hipXYnEJ->Fill(track_ipXYs[itrack]);
                        if(otfile) hipXYSignEJ->Fill(track_ipXYSigs[itrack]);
                    }
                }

            }
            //  std::cout<<"event pt alphaM cef nef ntrkpt1 r0 emerging  almost "<<event<<" "<<jet_pt->at(ij)<<" "<<jet_alpha[ij]<<" "<<jet_cef->at(ij)<<" "<<jet_nef->at(ij)<<" "<<jet_ntrkpt1[ij]<<" "<<r0[ij]<<" "<<emerging[ij]<<" "<<almostemerging[ij]<<std::endl;
        }// end of 2nd loop over jets
        if(otfile) h_nalemg->Fill(nalmostemerging);
        if(otfile) h_nemg->Fill(nemerging);

//         if(otfile) {//basicjets
//             for(int i=0;i<NNNjet;i++) {
//                 if(!basicjet[i]) continue;
//                 if(jet_pt->at(i)>minJetPt && fabs(jet_eta->at(i))<jetacut) {
//                     halpha->Fill(jet_alpha[i]);
//                     if (jet_alpha[i]==0) halphaZero->Fill(jet_alpha[i]);
//                 }
//             }
//         }


        // *************************************************************
        // now start the event selections
        // *************************************************************

        // require at least 4 jets
        bool C4jet=true;
        int nemgGoodjet = 0;
        int nalemgGoodjet = 0;
        vector<int> goodjetIdx;
        for(int nj=0;nj<NNNjet;nj++) {
            if (!basicjet[nj] || jet_pt->at(nj)<minJetPt) continue;
            goodjetIdx.push_back(nj);
            //std::cout << "Idx[" << nj <<"] is good jet" << std::endl;
            if (emerging[nj]) nemgGoodjet+=1;
            if (almostemerging[nj]) nalemgGoodjet+=1;
            if(otfile) {
                halpha->Fill(jet_alpha[nj]);
                if (jet_alpha[nj]==0) halphaZero->Fill(jet_alpha[nj]);
            }
        }

        //if(NNNjet<4) continue;
        if(goodjetIdx.size()!=4) {
            C4jet=false;
            //double HT0 = 0.;
            //for (int i = 0; i<NNNjet; i++) HT0 += jet_pt->at(i);
            //std::cout << "***event " << event << std::endl;
            //std::cout << "NNNjet = " << NNNjet << " =? jet_pt->size() = " << jet_pt->size() << "; HT = " << HT0 << "; jet_pt[" << NNNjet-1 << "] = " << jet_pt->at(NNNjet-1) << std::endl;
            continue;
        }

        double HT = 0;
        for(uint i=0;i<goodjetIdx.size();i++) {
            HT += jet_pt->at(goodjetIdx[i]);
        }
        // HT
        //double HT = jet_pt->at(0)+jet_pt->at(1)+jet_pt->at(2)+jet_pt->at(3);

        if(otfile) H_T->Fill(HT);
        if(otfile) hpt1->Fill(jet_pt->at(goodjetIdx[0]));
        if(otfile) hpt2->Fill(jet_pt->at(goodjetIdx[1]));
        if(otfile) hpt3->Fill(jet_pt->at(goodjetIdx[2]));
        if(otfile) hpt4->Fill(jet_pt->at(goodjetIdx[3]));
        // HLT efficiency plots:
        if(otfile) {
            if (hltTrig1n) hTrig1n->Fill(HT);
            if (hltTrig1d) hTrig1d->Fill(HT);
            if (hltTrig2n) hTrig2n->Fill(HT);
            if (hltTrig2d) hTrig2d->Fill(HT);
            if (hltTrig3n) hTrig3n->Fill(HT);
            if (hltTrig3d) hTrig3d->Fill(HT);
        }
        bool HLT=false;
        if (hltTrig3n) HLT=true;
        bool CHT=true;
        if(HT<HTcut) CHT=false;
        // jet pt
        bool Cpt1=false;
        bool Cpt2=false;
        bool Cpt3=false;
        bool Cpt4=false;
//         if((jet_pt->at(0)>pt1cut)&&(fabs(jet_eta->at(0))<jetacut)) Cpt1=true;
//         if((jet_pt->at(1)>pt2cut)&&(fabs(jet_eta->at(1))<jetacut)) Cpt2=true;
//         if((jet_pt->at(2)>pt3cut)&&(fabs(jet_eta->at(2))<jetacut)) Cpt3=true;
//         if((jet_pt->at(3)>pt4cut)&&(fabs(jet_eta->at(3))<jetacut)) Cpt4=true;
        // basicjet includes eta cut already
        if(jet_pt->at(goodjetIdx[0])>pt1cut) Cpt1=true;
        if(jet_pt->at(goodjetIdx[1])>pt2cut) Cpt2=true;
        if(jet_pt->at(goodjetIdx[2])>pt3cut) Cpt3=true;
        if(jet_pt->at(goodjetIdx[3])>pt4cut) Cpt4=true;

        // number emerging jets
        bool Cnem = true;
        //if(nemerging<NemergingCut) Cnem=false;
        //if(nemgGoodjet<NemergingCut) Cnem=false;
        switch (ntagType) {
        case 0: {if(nemgGoodjet<1) Cnem=false; break;}
        case 1: {if(nemgGoodjet!=1) Cnem=false; break;}
        case 2: {if(nemgGoodjet!=2) Cnem=false; break;}
        case 21: {if(nemgGoodjet!=2) Cnem=false; break;}
        case 3: {if(nemgGoodjet!=3) Cnem=false; break;}
        default: {if(nemgGoodjet<NemergingCut) Cnem=false; break;}
        }

        bool Canem =true;
        //if(nalmostemerging>=4) Canem=false;
        if(nalemgGoodjet>=4) Canem=false;


        //blind
        if(blind) {
            Cnem=false;
            Canem=false;
        }

        // *************************************************************
        // Block irrelevant to bkg estimation
        // *************************************************************
        // do some plots
        if(otfile) {

            // kine only plots
            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4) {
                hHTko->Fill(HT);
                hpt1ko->Fill(jet_pt->at(goodjetIdx[0]));
                hpt2ko->Fill(jet_pt->at(goodjetIdx[1]));
                hpt3ko->Fill(jet_pt->at(goodjetIdx[2]));
                hpt4ko->Fill(jet_pt->at(goodjetIdx[3]));
            }

            // jet plots
            for(int i=0;i<NNNjet;i++) {
                if(basicjet[i]) {
                    if(jet_pt->at(i)>minJetPt) {
                        haMgj->Fill(jet_alpha[i]);
                        haMvjpt->Fill(jet_alpha[i],jet_pt->at(i));
                        haMvHT->Fill(jet_alpha[i],HT);
                        haMvnvtx->Fill(jet_alpha[i],nVtx);
                        hjptb->Fill(jet_pt->at(i));
                        if(emerging[i]) {
                            hjpta->Fill(jet_pt->at(i));
                        }
                    }
                }
            }

            //N-1 plots
            if(HLT&&C4jet&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem) hHTnm1->Fill(HT);
            if(HLT&&C4jet&&CHT&&Cpt2&&Cpt3&&Cpt4&&Cnem&&Canem) hpt1nm1->Fill(jet_pt->at(goodjetIdx[0]));
            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt3&&Cpt4&&Cnem&&Canem) hpt2nm1->Fill(jet_pt->at(goodjetIdx[1]));
            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt4&&Cnem&&Canem) hpt3nm1->Fill(jet_pt->at(goodjetIdx[2]));
            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cnem&&Canem) hpt4nm1->Fill(jet_pt->at(goodjetIdx[3]));
            //if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem) hnemnm1->Fill(nemerging);
            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem) hnemnm1->Fill(nemgGoodjet);
            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem) {
                for(int i=0;i<4;i++) {
                    int idx = goodjetIdx[i];
                    if(basicjet[idx]) {
                        halphanm1->Fill(jet_alpha[idx]);
                        aMip->Fill(jet_alpha[idx],r0[idx]);
                        hntrk1nm1->Fill(jet_ntrkpt1[idx]);
                        if((jet_alpha[idx]<alphaMaxcut && jet_alpha[idx]>-1)) {
                            hmaxipnm1->Fill(r0[idx]);
                            //std::cout<<" almost emerging"<<std::endl;
                            if(r0[idx]<0.05) std::cout<<"DANGER DANGER"<<std::endl;
                            vector<float> track_pts = track_pt->at(i);
                            vector<int> track_sources = track_source->at(i);
                            vector<int> track_qualitys = track_quality->at(i);
                            //vector<float> track_vertex_weights = track_vertex_weight->at(i);
                            vector<float> track_pvWeights = track_pvWeight->at(i);
                            vector<float> track_ipXYs = track_ipXY->at(i);
                            vector<float> track_ipXYSigs = track_ipXYSig->at(i);
                            vector<int> track_nMissInnerHitss = track_nMissInnerHits->at(i);
                            vector<int> track_nMissInnerPxlLayerss = track_nMissInnerPxlLayers->at(i);
                            vector<int> track_nPxlLayerss = track_nPxlLayers->at(i);
                            vector<int> track_nHitss = track_nHits->at(i);
                            vector<float> track_ipZs = track_ipZ->at(i);
                            vector<float> track_ref_zs = track_ref_z->at(i);//analysis_20170523_v0
                            for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
                                if(track_sources[itrack]==0 && ((track_qualitys[itrack] & 4) > 0)) {
                                    if (fabs(pv_z-track_ref_zs[itrack])>pilecut) continue;//analysis_20170523_v0
                                    if(otfile) hnHitsnm1->Fill(track_nHitss[itrack]);
                                }
                            }

                        }
                    }
                }
            }


            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&nalmostemerging>=2) {
                if(otfile) H_T4->Fill(HT);
                for(int i=0;i<4;i++) {
                    int idx = goodjetIdx[i];
                    if(almostemerging[idx]) {
                        if((jet_alpha[idx]<alphaMaxcut && jet_alpha[idx]>-1)) {
                            hnmaxipnm1->Fill(r0[idx]);
                        }
                    }
                }
            }

            if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&nalmostemerging>=1) {
                for(int i=0;i<4;i++) {
                    int idx = goodjetIdx[i];
                    if(almostemerging[idx]) {
                        if((jet_alpha[idx]<alphaMaxcut && jet_alpha[idx]>-1)) {
                            hn2maxipnm1->Fill(r0[idx]);
                        }
                    }
                }
            }
        }//end of do some plots
        // N-1 plots


        // make plots for fake rate studes
        if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4&&Canem&&otfile) {
            for(Int_t j=0; j<NNNjet; j++) {
                if(basicjet[j]) {
                    hjptfrb->Fill(jet_pt->at(j));
                    if(almostemerging[j]){
                        hjptfra1->Fill(jet_pt->at(j));
                        if(emerging[j]) {
                            hjptfra2->Fill(jet_pt->at(j));
                        }
                    }
                }
            }
        }
        // check without Canem
        if(HLT&&C4jet&&CHT&&Cpt1&&Cpt2&&Cpt3&&Cpt4) {
            for(Int_t j=0; j<NNNjet; j++) {
                if(basicjet[j]) {
                    if (otfile){
                        halphaPS->Fill(jet_alpha[j]);
                        if (jet_alpha[j]==0) halphaZeroPS->Fill(jet_alpha[j]);
                        hmedipXYSigPS->Fill(jet_medipsig[j]);
                        hlogmedipXYSigPS->Fill(jet_logmedipsig[j]);
                        hmedtheta2DPS->Fill(jet_medtheta2D[j]);
                        hlogmedtheta2DPS->Fill(jet_logmedtheta2D[j]);

                        halphavtheta2DPS->Fill(jet_alpha[j],jet_medtheta2D[j]);
                        halphavipXYSigPS->Fill(jet_alpha[j],jet_medipsig[j]);
                        htheta2DvipXYSigPS->Fill(jet_medtheta2D[j],jet_medipsig[j]);

                        hjptfrbc->Fill(jet_pt->at(j));
                    }
                    if(almostemerging[j]){
                        if (otfile) hjptfra1c->Fill(jet_pt->at(j));
                        if(emerging[j] && otfile) {
                            hjptfra2c->Fill(jet_pt->at(j));
                        }
                    }
                }
            }
        }
        // *************************************************************
        // Enf of block irrelevant to bkg estimation
        // *************************************************************


        // *************************************************************
        // apply cuts sequentially
        // *************************************************************

        //    std::cout<<"c4jet cht cpt1 cpt2 cpt3 cpt4 cnem "<<C4jet<<" "<<CHT<<" "<<Cpt1<<" "<<Cpt2<<" "<<Cpt3<<" "<<Cpt4<<" "<<Cnem<<std::endl;
        if (HLT && otfile) {
            count->Fill("HLT",1);
            acount->Fill(1);
            H_T0->Fill(HT);
        }

        if(HLT && C4jet) {
            if(otfile) count->Fill("4 jets",1);
            if(otfile) acount->Fill(2);
            if(otfile) H_T1->Fill(HT);

            // calculate HT and require it greater than some cut value
            if(CHT) {
                if(otfile) count->Fill("HT",1);
                if(otfile) acount->Fill(3);
                if(otfile) H_T2->Fill(HT);

                // do pT cuts on jets  
                if(Cpt1) {
                    if(otfile) count->Fill("jet pt1",1);
                    if(otfile) acount->Fill(4);

                    if(Cpt2) {
                        if(otfile) count->Fill("jet pt2",1);
                        if(otfile) acount->Fill(5);

                        if(Cpt3) {
                            if(otfile) count->Fill("jet pt3",1);
                            if(otfile) acount->Fill(6);

                            if(Cpt4) {
                                if(otfile) {
                                    int njetsFR = 4;
                                    count->Fill("jet pt4",1);
                                    acount->Fill(7);

                                    if(Canem) {
                                        //h_nemgSR->Fill(nemerging);
                                        h_nemgSR->Fill(nemgGoodjet);

                                        // ********************************
                                        // Data-driven fake background
                                        // ********************************
                                        int ngoodjet = 0;
                                        for(int nj=0;nj<NNNjet;nj++) {
                                            if (!basicjet[nj] || jet_pt->at(nj)<minJetPt) continue;
                                            ngoodjet+=1;
                                        }
                                        // ngoodjet should be = goodjetIdx.size()
                                        //std::cout << "ngoodjet = " << ngoodjet << " ?= " << "goodjetIdx.size() = " << goodjetIdx.size() << std::endl;
                                        //double nGJwgt = nGJrewgt(goodjetIdx.size());
                                        double nGJwgt = 1.0;

                                        // Default:
                                        double frwgt0 = frWeightFT0(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType);
                                        double frwgt1 = frWeightFT1(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType);
                                        double frwgt2 = frWeightFT2(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType);
                                        double frwgt3 = frWeightFT3(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType);

                                        // Alternatives:
                                        double frwgt21 = frWeightT21(jet_pt,jet_eta,goodjetIdx,jntrack,njetsFR,minJetPt,varType);
                                        double frwgtge2 = frWeight1(jet_pt,jet_eta,goodjetIdx,jntrack,njetsFR,minJetPt,varType);

                                        // Choose event-wise weight
                                        double frwgt = 1.0;
                                        switch (ntagType) {
                                        case 0: frwgt = nGJwgt*(1.0 - frwgt0); break;//>=1 tag
                                        case 1: frwgt = nGJwgt*frwgt1; break;//==1 tag
                                        case 2: frwgt = nGJwgt*frwgt2; break;//==2 tag
                                        case 3: frwgt = nGJwgt*frwgt3; break;//==3 tag (not implemented yet)
                                        case 21: frwgt = nGJwgt*frwgt21; break;//==2 tag; tag-and-probe
                                        default: frwgt = nGJwgt*frwgtge2; break;//>=2tag (need to check calculation)
                                        }

                                        // Fill histograms
                                        hnjetFR->Fill(ngoodjet,frwgt);
                                        count->Fill("FakeRateBKG",frwgt);
                                        acount->Fill(10,frwgt);
                                        hfrwgt->Fill(frwgt);
                                        H_TFR->Fill(HT,frwgt);
                                        np0 += frwgt0;
                                        np1 += frwgt1;

                                        if (ntagType==2) np2 += frwgt2;
                                        else np2 += frwgt21;

                                        np3 += frwgt3;

                                        h_nemgFR->Fill(0.0,frWeightFT0(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType));
                                        h_nemgFR->Fill(1.0,frWeightFT1(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType));

                                        if (ntagType==2)
                                            h_nemgFR->Fill(2.0,frWeightFT2(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType));
                                        else
                                            h_nemgFR->Fill(2.0,frWeightT21(jet_pt,jet_eta,goodjetIdx,jntrack,njetsFR,minJetPt,varType));

                                        h_nemgFR->Fill(3.0,frWeightFT3(jet_pt,jet_eta,goodjetIdx,jntrack,jet_pid_maxEt,njetsFR,minJetPt,varType));
                                        //h_nemgFR->Fill(4.0,1-frwgt0-frwgt1-frwgt2);//x-check w.r.t. 3.0 ==> verified
                                        switch (ntagType) {
                                        case 1: {
                                            // For Ntag==1
                                            for(int i3=0;i3<njetsFR;i3++) {
                                                int idx3 = goodjetIdx[i3];
                                                double jfr = fakerateF(jet_pt->at(idx3),jet_eta->at(idx3),jntrack[idx3],
                                                                       varType,jet_pid_maxEt[idx3]);
                                                for(int i31=0;i31<njetsFR;i31++) {
                                                    int idx31 = goodjetIdx[i31];
                                                    if (i31 != i3) jfr *= (1.0-fakerateF(jet_pt->at(idx31),jet_eta->at(idx31),
                                                                                         jntrack[idx31],varType,jet_pid_maxEt[idx31]));
                                                }
                                                if (!basicjet[idx3] || jet_pt->at(idx3)<minJetPt) continue;
                                                hjptaFR->Fill(jet_pt->at(idx3),jfr);
                                                hetaaFR->Fill(jet_eta->at(idx3),jfr);
                                                hntrkFR->Fill(jntrack[idx3],jfr);
                                                hmedipXYSigFR->Fill(jet_medipsig[idx3],jfr);
                                                hlogmedipXYSigFR->Fill(jet_logmedipsig[idx3],jfr);
                                                hmedtheta2DFR->Fill(jet_medtheta2D[idx3],jfr);
                                                hlogmedtheta2DFR->Fill(jet_logmedtheta2D[idx3],jfr);
                                                htheta2DvipXYSigFR->Fill(jet_medtheta2D[idx3],jet_medipsig[idx3],jfr);

                                                for(int i4=0;i4<njetsFR;i4++) {
                                                    if (i4 == i3) continue;
                                                    int idx4 = goodjetIdx[i4];
                                                    if (!basicjet[idx4] || jet_pt->at(idx4)<minJetPt) continue;
                                                    double mass = sqrt(
                                                                       pow((jet_e[idx3]+jet_e[idx4]),2) -
                                                                       pow((jet_px[idx3]+jet_px[idx4]),2) -
                                                                       pow((jet_py[idx3]+jet_py[idx4]),2) -
                                                                       pow((jet_pz[idx3]+jet_pz[idx4]),2)
                                                                       );
                                                    hmassFR->Fill(mass,jfr);
                                                }
                                            }
                                            break;
                                        }//end case 1 (Ntag==1)
                                        case 2: {
                                            // For Ntag==2; flav dep
                                            frwgt*=0.5;// combinatorics
                                            double frwgttmp=0.;
                                            for(int i1=0;i1<njetsFR;i1++) {
                                                int idx1 = goodjetIdx[i1];
                                                if (!basicjet[idx1] || jet_pt->at(idx1)<minJetPt) continue;
                                                double jfr = fakerateF(jet_pt->at(idx1),jet_eta->at(idx1),jntrack[idx1],
                                                                       varType,jet_pid_maxEt[idx1]);
                                                for(int i2=0;i2<njetsFR;i2++) {
                                                    int idx2 = goodjetIdx[i2];
                                                    if (!basicjet[idx2] || jet_pt->at(idx2)<minJetPt) continue;
                                                    if (i2==i1) continue;
                                                    double kfr = jfr*(1.0-fakerateF(jet_pt->at(idx2),jet_eta->at(idx2),jntrack[idx2],
                                                                                    varType,jet_pid_maxEt[idx2]));
                                                    for(int i3=0;i3<njetsFR;i3++) {
                                                        if (i3==i1 || i3==i2) continue;
                                                        int idx3 = goodjetIdx[i3];
                                                        if (!basicjet[idx3] || jet_pt->at(idx3)<minJetPt) continue;
                                                        double lfr = kfr*fakerateF(jet_pt->at(idx3),jet_eta->at(idx3),jntrack[idx3],
                                                                                   varType,jet_pid_maxEt[idx3]);
                                                        for(int i4=0;i4<njetsFR;i4++) {
                                                            if (i4==i1 || i4==i2 || i4==i3) continue;
                                                            int idx4 = goodjetIdx[i4];
                                                            if (!basicjet[idx4] || jet_pt->at(idx4)<minJetPt) continue;
                                                            lfr *= (1.0-fakerateF(jet_pt->at(idx4),jet_eta->at(idx4),jntrack[idx4],
                                                                                  varType,jet_pid_maxEt[idx4]));
                                                        }
                                                        //take care of combinatorics: e.g., var(1) double counted by (1_tag,2)(3_tag,4) and (1_tag,4)(3_tag,2)
                                                        double varWgt = lfr/2;
                                                        frwgttmp += varWgt;

                                                        hjptaFR->Fill(jet_pt->at(idx1),varWgt);
                                                        hetaaFR->Fill(jet_eta->at(idx1),varWgt);
                                                        hntrkFR->Fill(jntrack[idx1],varWgt);
                                                        hmedipXYSigFR->Fill(jet_medipsig[idx1],varWgt);
                                                        hlogmedipXYSigFR->Fill(jet_logmedipsig[idx1],varWgt);
                                                        hmedtheta2DFR->Fill(jet_medtheta2D[idx1],varWgt);
                                                        hlogmedtheta2DFR->Fill(jet_logmedtheta2D[idx1],varWgt);
                                                        htheta2DvipXYSigFR->Fill(jet_medtheta2D[idx1],jet_medipsig[idx1],varWgt);

                                                        double mass = sqrt(
                                                                           pow((jet_e[idx1]+jet_e[idx2]),2) -
                                                                           pow((jet_px[idx1]+jet_px[idx2]),2) -
                                                                           pow((jet_py[idx1]+jet_py[idx2]),2) -
                                                                           pow((jet_pz[idx1]+jet_pz[idx2]),2)
                                                                           );
                                                        hmassFR->Fill(mass,lfr);
                                                    }
                                                }
                                            }
                                            if (fabs(frwgt*4-frwgttmp)>1.e-7) {
                                                std::cout << "[WARNING] frwgtx4 = " << std::setprecision(9)
                                                          << frwgt*4 << " != frwgttmp = " << frwgttmp << "!!!!" << std::endl;
                                            }
                                            break;
                                        }//end case 2 (Ntag==2; flav dep)
                                        case 21: {
                                            // For Ntag==2; tag-and-probe
                                            frwgt*=0.5;// combinatorics
                                            double frwgttmp=0.;
                                            for(int i1=0;i1<njetsFR;i1++) {
                                                int idx1 = goodjetIdx[i1];
                                                if (!basicjet[idx1] || jet_pt->at(idx1)<minJetPt) continue;
                                                double jfr = fakerate(jet_pt->at(idx1),jet_eta->at(idx1),jntrack[idx1],varType);
                                                for(int i2=0;i2<njetsFR;i2++) {
                                                    int idx2 = goodjetIdx[i2];
                                                    if (!basicjet[idx2] || jet_pt->at(idx2)<minJetPt) continue;
                                                    if (i2==i1) continue;
                                                    double kfr = jfr*(1.0-fakerateTP(jet_pt->at(idx2),jet_eta->at(idx2),jntrack[idx2],varType));
                                                    //kfr *= (1.0-fakerate(jet_pt->at(idx2),jet_eta->at(idx2),jntrack[idx2],varType));
                                                    for(int i3=0;i3<njetsFR;i3++) {
                                                        if (i3==i1 || i3==i2) continue;
                                                        int idx3 = goodjetIdx[i3];
                                                        if (!basicjet[idx3] || jet_pt->at(idx3)<minJetPt) continue;
                                                        double lfr = kfr*fakerateTP(jet_pt->at(idx3),jet_eta->at(idx3),jntrack[idx3],varType);
                                                        for(int i4=0;i4<njetsFR;i4++) {
                                                            if (i4==i1 || i4==i2 || i4==i3) continue;
                                                            int idx4 = goodjetIdx[i4];
                                                            if (!basicjet[idx4] || jet_pt->at(idx4)<minJetPt) continue;
                                                            lfr *= (1.0-fakerateTP(jet_pt->at(idx4),jet_eta->at(idx4),jntrack[idx4],varType));
                                                            //lfr *= (1.0-fakerate(jet_pt->at(idx4),jet_eta->at(idx4),jntrack[idx4],varType));
                                                        }
                                                        //take care of combinatorics: e.g., var(1) double counted by (1_tag,2)(3_tag,4) and (1_tag,4)(3_tag,2)
                                                        double varWgt = lfr/2;
                                                        frwgttmp += varWgt;

                                                        hjptaFR->Fill(jet_pt->at(idx1),varWgt);
                                                        hetaaFR->Fill(jet_eta->at(idx1),varWgt);
                                                        hntrkFR->Fill(jntrack[idx1],varWgt);
                                                        hmedipXYSigFR->Fill(jet_medipsig[idx1],varWgt);
                                                        hlogmedipXYSigFR->Fill(jet_logmedipsig[idx1],varWgt);
                                                        hmedtheta2DFR->Fill(jet_medtheta2D[idx1],varWgt);
                                                        hlogmedtheta2DFR->Fill(jet_logmedtheta2D[idx1],varWgt);
                                                        htheta2DvipXYSigFR->Fill(jet_medtheta2D[idx1],jet_medipsig[idx1],varWgt);

                                                        double mass = sqrt(
                                                                           pow((jet_e[idx1]+jet_e[idx2]),2) -
                                                                           pow((jet_px[idx1]+jet_px[idx2]),2) -
                                                                           pow((jet_py[idx1]+jet_py[idx2]),2) -
                                                                           pow((jet_pz[idx1]+jet_pz[idx2]),2)
                                                                           );
                                                        hmassFR->Fill(mass,lfr);
                                                    }
                                                }
                                            }
                                            if (fabs(frwgt*4-frwgttmp)>1.e-7) {
                                                std::cout << "[WARNING] frwgtx4 = " << std::setprecision(9)
                                                          << frwgt*4 << " != frwgttmp = " << frwgttmp << "!!!!" << std::endl;
                                            }
                                            break;
                                        }//end case 21 (Ntag==2; tag-and-probe)

                                        default: break;
                                        }//end switch
                                    }// Canem
                                }
                                // ********************************
                                // SR
                                // ********************************
                                // require at least N emerging jets
                                if(Cnem) {//NOTE: revert Canem and Cnem for the time being
                                    if(otfile) count->Fill("emerging",1);
                                    if(otfile) acount->Fill(8);

                                    if(Canem) {
                                        if(otfile) count->Fill("almostemerging",1);
                                        if(otfile) acount->Fill(9);

                                        npass+=1;
                                        std::cout<<"passing run lumi event filename is "<<run<<" "<<lumi<<" "<<event<<" "<<inputfilename<<std::endl;
                                        for(int i=0;i<4;i++) {
                                            int idx = goodjetIdx[i];
                                            std::cout<<"  for jet "<<i<<" pt eta nef cfe ntrkpt1 alphamax r0"<<std::endl;
                                            std::cout<<"     "<<jet_pt->at(idx)<<" "<<jet_eta->at(idx)<<" "<< jet_nef->at(idx)<<" "<< jet_cef->at(idx)<<" "<<jet_ntrkpt1[idx]<<" "<<jet_alpha[idx]<<" "<<r0[idx]<<" "<<std::endl;
                                        }
                                        if(otfile) {
                                            H_T3->Fill(HT);

                                            int ngoodjetSR = 0;
                                            for(int nj=0;nj<NNNjet;nj++) {
                                                if (!basicjet[nj] || jet_pt->at(nj)<minJetPt) continue;
                                                ngoodjetSR+=1;
                                            }
                                            hnjetSR->Fill(ngoodjetSR);

                                            for(int i5=0;i5<4;i5++) {
                                                int idx5 = goodjetIdx[i5];
                                                if (jet_pt->at(idx5)<minJetPt) continue;
                                                if (emerging[idx5] && otfile){
                                                    hjptaSR->Fill(jet_pt->at(idx5));
                                                    hetaaSR->Fill(jet_eta->at(idx5));
                                                    hntrkSR->Fill(jntrack[idx5]);
                                                    hmedipXYSigSR->Fill(jet_medipsig[idx5]);
                                                    hlogmedipXYSigSR->Fill(jet_logmedipsig[idx5]);
                                                    hmedtheta2DSR->Fill(jet_medtheta2D[idx5]);
                                                    hlogmedtheta2DSR->Fill(jet_logmedtheta2D[idx5]);
                                                    htheta2DvipXYSigSR->Fill(jet_medtheta2D[idx5],jet_medipsig[idx5]);
                                                }
                                                for(int i6=i5+1;i6<4;i6++) {
                                                    int idx6 = goodjetIdx[i6];
                                                    if (jet_pt->at(idx6)<minJetPt) continue;
                                                    if((emerging[idx5]&&!emerging[idx6])||(!emerging[idx5]&&emerging[idx6])) {
                                                        double mass = sqrt(
                                                                           pow((jet_e[idx5]+jet_e[idx6]),2) -
                                                                           pow((jet_px[idx5]+jet_px[idx6]),2) -
                                                                           pow((jet_py[idx5]+jet_py[idx6]),2) -
                                                                           pow((jet_pz[idx5]+jet_pz[idx6]),2)
                                                                           );
                                                        hmass->Fill(mass);
                                                    }
                                                }
                                            }
                                        }
                                        std::cout<<"npass  event is "<<npass<<" "<<event<<std::endl;
                                        std::cout<<"nemerging nalmostemerging "<<nemerging<<" "<<nalmostemerging<<std::endl;
                                        std::cout<<"nemgGoodjet nalemgGoodjet "<<nemgGoodjet<<" "<<nalemgGoodjet<<std::endl;
                                    }//Canem
                                }//Cnem
                            }//Cpt4
                        }//Cpt3
                    }//Cpt2
                }//Cpt1
            }//CHT
        }//HLT&C4jet
    }// end of loop over events

    std::cout << "np0 = " << np0 << std::endl;
    std::cout << "np1 = " << np1 << std::endl;
    std::cout << "np2 = " << np2 << std::endl;
    std::cout << "np3 = " << np3 << std::endl;

    if(otfile) {
        TFile myfile(outputfilename,"RECREATE");
        count->LabelsDeflate();
        count->LabelsOption("v");
        //  count->LabelsOption("a");

        eventCountPreTrigger->Write();
        acount->Write();
        count->Write();
        hfrwgt->Write();
        hjetcut->Write();
        hpt->Write();
        hnjet->Write();
        hnjetSR->Write();
        hnjetFR->Write();
        heta->Write();
        heta2->Write();
        hetaaSR->Write();
        hetaaFR->Write();
        halpha->Write();
        halphaZero->Write();
        haMgj->Write();
        H_T->Write();
        H_T0->Write();
        H_T1->Write();
        H_T2->Write();
        H_T3->Write();
        H_T4->Write();
        H_TFR->Write();
        hpt1->Write();
        hpt2->Write();
        hpt3->Write();
        hpt4->Write();
        h_nemg->Write();
        h_nemgSR->Write();
        h_nemgFR->Write();
        h_nalemg->Write();
        hjetchf->Write();
        hbcut_ntrkpt1->Write();
        hacut_ntrkpt1->Write();
        hbcut_nef->Write();
        hacut_nef->Write();
        hbcut_cef->Write();
        hacut_cef->Write();
        hbcut_alphamax->Write();
        hacut_alphamax->Write();
        hHTnm1->Write();
        hpt1nm1->Write();
        hpt2nm1->Write();
        hpt3nm1->Write();
        hpt4nm1->Write();
        halphanm1->Write();
        hmaxipnm1->Write();
        hnmaxipnm1->Write();
        hn2maxipnm1->Write();
        hnHitsnm1->Write();
        hntrk1nm1->Write();
        hntrkSR->Write();
        hntrkFR->Write();
        hnemnm1->Write();
        hipXYEJ->Write();
        hipXYnEJ->Write();
        htvw->Write();
        htvwEJ->Write();
        hipXYSigEJ->Write();
        hipXYSignEJ->Write();
        hmaxipXYEJ->Write();
        hmaxipXYnEJ->Write();
        hmeanipXYEJ->Write();
        hmeanipXYnEJ->Write();
        hmedipXYEJ->Write();
        hmedipXYnEJ->Write();
        hmeanipXYSigEJ->Write();
        hmeanipXYSignEJ->Write();
        hmedipXYSigEJ->Write();
        hmedipXYSignEJ->Write();
        hmedtheta2DEJ->Write();
        hmedtheta2DnEJ->Write();
        hlogmeanipXYSigEJ->Write();
        hlogmeanipXYSignEJ->Write();
        hlogmedipXYSigEJ->Write();
        hlogmedipXYSignEJ->Write();
        hlogmedtheta2DEJ->Write();
        hlogmedtheta2DnEJ->Write();
        hjptb->Write();
        hjpta->Write();
        hjptaSR->Write();
        hjptaFR->Write();
        hjptfrb->Write();
        hjptfra1->Write();
        hjptfra2->Write();
        hjptfrbc->Write();
        hjptfra1c->Write();
        hjptfra2c->Write();
        hHTko->Write();
        hpt1ko->Write();
        hpt2ko->Write();
        hpt3ko->Write();
        hpt4ko->Write();
        hmass->Write();
        hmassFR->Write();
        hTrig1n->Write();
        hTrig1d->Write();
        hTrig2n->Write();
        hTrig2d->Write();
        hTrig3n->Write();
        hTrig3d->Write();

        halphaPS->Write();
        halphaZeroPS->Write();
        hmedipXYSigPS->Write();
        hmedtheta2DPS->Write();
        hlogmedipXYSigPS->Write();
        hlogmedtheta2DPS->Write();

        hmedipXYSigSR->Write();
        hmedtheta2DSR->Write();
        hlogmedipXYSigSR->Write();
        hlogmedtheta2DSR->Write();

        hmedipXYSigFR->Write();
        hmedtheta2DFR->Write();
        hlogmedipXYSigFR->Write();
        hlogmedtheta2DFR->Write();

        //2d
        aMip->Write();
        haMvjpt->Write();
        haMvHT->Write();
        haMvnvtx->Write();

        halphavtheta2D->Write();
        halphavipXYSig->Write();
        htheta2DvipXYSig->Write();

        halphavtheta2DPS->Write();
        halphavipXYSigPS->Write();
        htheta2DvipXYSigPS->Write();

        htheta2DvipXYSigSR->Write();
        htheta2DvipXYSigFR->Write();

        myfile.Close();
    }

    tt->ResetBranchAddresses();
  
    delete jet_index;
    delete jet_source;
    delete jet_pt;
    delete jet_eta;
    delete jet_phi;
    delete jet_alphaMax;
    delete jet_cef;
    delete jet_nef;
    delete jet_chf;
    delete jet_theta2D;
    //  delete jet_phf;
    delete track_pt;
    delete track_eta;
    delete track_source;
    delete track_index;
    delete track_jet_index;
    delete track_vertex_index;
    delete track_algo;
    delete track_quality;
    delete track_vertex_weight;
    delete track_pvWeight;
    delete track_ipZ;
    delete track_ipXY;
    delete track_ipXYSig;
  


    f->Close();
  


    return npass;
}
