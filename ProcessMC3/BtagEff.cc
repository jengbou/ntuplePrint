#include <iostream>
#include <iomanip>
#include <locale>

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>
#include <TMatrixD.h>

#include "vector"
using std::vector;
#include "algorithm"

#include <TH2.h>
#include <TStyle.h>
#include <TCanvas.h>
#include "EMJselect.h"
#include "EMJ16003.h"
#include "QCDhists.h"
#include "BtagEff.h"


float DeltaR1(float eta1, float phi1, float eta2, float phi2) {

    float dR=0.;
    float deta = std::fabs(eta1-eta2);
    float dphi = std::fabs(phi1-phi2);
    if(dphi>3.14159) dphi = 2.*3.14159-dphi;
    dR=std::sqrt(deta*deta+dphi*dphi);

    return dR;
}


int BtagEff(bool otfile, bool hasPre, const char* inputfilename,const char* outputfilename,
            float HTcut, float pt1cut, float pt2cut, float pt3cut, float pt4cut, float jetacut,float alphaMaxcut, float maxIPcut, float NemfracCut,float CemfracCut,int ntrk1cut, int NemergingCut,bool blind,bool isData) {


    float pilecut=2.5;//cm
    float pilecut2=pilecut;//cm
    float pvztrkcut=0.01;//cm
    float ipXYsigcut=2.0;
    float METcut=0.0;
    float sigzCut=4.0;

    double minJetPt = 100.0;
    const int varType = 3;// 1: alpha; 2: alpha2Dsig; 3 (default): alpha3Dsig
    const int ntagType = 22; //0:>=1 tag; 1: ==1 tag; 2: == 2 tag (flav dep); 21: == 2 tag (T&P); 22: == 2 tag (flav dep; data unfolded); 3: == 3 tag; else: >= NemergingCut tag

    Int_t  ptbinnum = 9;
    Float_t ptbins[10] = {20, 30, 50, 70, 100, 140, 200, 300, 600, 1000};
    Int_t  etabinnum = 6;
    Float_t etabins[7] = {-3.0,-2.0,-1.4442,0.0,1.4442,2.0,3.0};

    //btagging related
    float bTagWP=0.5426;//0.90095;//0.627516656;//0.5426;//0.8484;//0.9535;//CSVv2T defined here:  https://twiki.cern.ch/twiki/bin/viewauth/CMS/BtagRecommendation80XReReco
    //int bUnfType=1;//1: loose (0.5426); 2: medium (0.8484); 3: tight (0.9535)
    //int ptType=1;//1: low pT; 2: high pT
    // btagging related

    // "ntuple.root", "histos.root"
    // suggest cuts 1000., 400.,200.,125.,50.,0.2,0.9,0.9,0,1
    // right now this code hard wires the jet pT cut and requires emerging jets to have at least
    // one track with pT> 1 GeV

    // read the Tree generated by tree1w and fill two histograms
    // note that we use "new" to create the TFile and TTree objects,
    // to keep them alive after leaving this function.
    //NemergingCut=1;
    if (minJetPt>pt4cut) minJetPt = pt4cut;
    QCDhists* qcdtools=0;

    int npass=0;

    TFile *f = new TFile(inputfilename);
    if(f->IsZombie()) {
        std::cout << "File: " << inputfilename << " does not exist." << std::endl;
        return 0;
    }

    // get histogram of events before trigger
    TH1F *eventCountPreTrigger;

    if(hasPre) {
        if(otfile) eventCountPreTrigger = static_cast<TH1F*>(f->Get("eventCountPreTrigger/eventCountPreTrigger")->Clone());
    } else {
        if(otfile)  eventCountPreTrigger = new TH1F("eventCountPreTrigger","haha",2,0.,2.);
    }

    std::cout << "CSV batgger cut used = " << bTagWP << std::endl;

    TTree *tt = (TTree*)f->Get("emJetAnalyzer/emJetTree");

    Int_t nVtx, event, lumi, run, nTrueInt, nTracks;//, pv_indexInColl;//analysis_20170523_v0
    Float_t met_pt, met_phi;//, pv_index;
    bool hltTrig1n, hltTrig1d, hltTrig2n, hltTrig2d, hltTrig3n, hltTrig3d;
    //float pv_z;//analysis_20170523_v0

    vector<int> *pv_index=0;//analysis_20170609_v0
    vector<float> *pv_zv=0;//analysis_20170609_v0

    vector<int> *jet_index=0;
    vector<int> *jet_source=0;
    vector<float> *jet_pt = 0;
    vector<float> *jet_eta = 0;
    vector<float> *jet_phi = 0;
    vector<float> *jet_alphaMax = 0;
    vector<float> *jet_cef = 0;
    vector<float> *jet_nef = 0;
    vector<float> *jet_chf = 0;
    vector<float> *jet_nhf = 0;
    vector<float> *jet_theta2D = 0;
    //  vector<float> *jet_phf = 0;
    vector<float> *jet_csv = 0;
    vector<vector<float> > *track_pt = 0;
    vector<vector<float> > *track_eta = 0;
    vector<vector<int> > *track_source = 0;
    vector<vector<int> > *track_index = 0;
    vector<vector<int> > *track_jet_index = 0;
    vector<vector<int> > *track_vertex_index = 0;
    vector<vector<int> > *track_algo = 0;
    vector<vector<int> > *track_quality = 0;
    vector<vector<float> > *track_vertex_weight =0;
    vector<vector<float> > *track_pvWeight = 0;
    vector<vector<float> > *track_ipZ =0;
    vector<vector<float> > *track_ipXY = 0;
    vector<vector<float> > *track_ipXYSig = 0;
    vector<vector<float> > *track_ref_z =0;//analysis_20170523_v0
    vector<vector<int> > *track_nMissInnerHits = 0;
    vector<vector<int> > *track_nMissInnerPxlLayers = 0;
    vector<vector<int> > *track_nPxlLayers = 0;
    vector<vector<int> > *track_nHits = 0;

    /*
      vector<int> *vertex_index=0;
      vector<int> *vertex_source=0;
      vector<float> *vertex_z =0;
    */

    // gen particles
    vector<int> *gp_index = new vector<int>;
    vector<int> *gp_pdgId = new vector<int>;
    vector<float> *gp_pt = new vector<float>;
    vector<float> *gp_eta = new vector<float>;
    vector<float> *gp_phi = new vector<float>;
    vector<int> *gp_charge = new vector<int>;
    vector<int> *gp_status = new vector<int>;
    vector<float> *gp_vx = new vector<float>;
    vector<float> *gp_vy = new vector<float>;
    vector<float> *gp_vz = new vector<float>;
    //get event count pre trigger


    // gen particles
    tt->SetBranchAddress("gp_index",&gp_index);
    tt->SetBranchAddress("gp_pdgId",&gp_pdgId);
    tt->SetBranchAddress("gp_pt",&gp_pt);
    tt->SetBranchAddress("gp_eta",&gp_eta);
    tt->SetBranchAddress("gp_phi",&gp_phi);
    tt->SetBranchAddress("gp_charge",&gp_charge);
    tt->SetBranchAddress("gp_status",&gp_status);
    tt->SetBranchAddress("gp_vx",&gp_vx);
    tt->SetBranchAddress("gp_vy",&gp_vy);
    tt->SetBranchAddress("gp_vz",&gp_vz);

    //for ntuple
    //tt->SetBranchAddress("pv_indexInColl",&pv_indexInColl);//analysis_20170523_v0
    tt->SetBranchAddress("pv_z",&pv_zv);
    tt->SetBranchAddress("pv_index",&pv_index);//analysis_20170609_v0
    tt->SetBranchAddress("nVtx",&nVtx);
    tt->SetBranchAddress("nTrueInt",&nTrueInt);
    tt->SetBranchAddress("nTracks",&nTracks);
    tt->SetBranchAddress("event",&event);
    tt->SetBranchAddress("lumi",&lumi);
    tt->SetBranchAddress("run",&run);
    tt->SetBranchAddress("met_pt",&met_pt);
    tt->SetBranchAddress("met_phi",&met_phi);
    tt->SetBranchAddress("jet_index",&jet_index);
    tt->SetBranchAddress("jet_source",&jet_source);
    //tt->SetBranchAddress("jet_ptRaw",&jet_pt);//analysis_20170523_v0
    tt->SetBranchAddress("jet_pt",&jet_pt);
    tt->SetBranchAddress("jet_eta",&jet_eta);
    tt->SetBranchAddress("jet_phi",&jet_phi);
    tt->SetBranchAddress("jet_cef",&jet_cef);
    tt->SetBranchAddress("jet_nef",&jet_nef);
    tt->SetBranchAddress("jet_chf",&jet_chf);
    tt->SetBranchAddress("jet_nhf",&jet_nhf);
    tt->SetBranchAddress("jet_theta2D",&jet_theta2D);//median of assoc. trk. theta2Ds.
    //  tt->SetBranchAddress("jet_phf",&jet_phf);
    tt->SetBranchAddress("jet_csv",&jet_csv);
    tt->SetBranchAddress("jet_alphaMax",&jet_alphaMax);
    tt->SetBranchAddress("track_pt",&track_pt);
    tt->SetBranchAddress("track_eta",&track_eta);
    tt->SetBranchAddress("track_source",&track_source);
    tt->SetBranchAddress("track_index",&track_index);
    tt->SetBranchAddress("track_jet_index",&track_jet_index);
    tt->SetBranchAddress("track_algo",&track_algo);
    tt->SetBranchAddress("track_quality",&track_quality);
    tt->SetBranchAddress("track_vertex_index",&track_vertex_index);
    tt->SetBranchAddress("track_vertex_weight",&track_vertex_weight);
    tt->SetBranchAddress("track_pvWeight",&track_pvWeight);
    tt->SetBranchAddress("track_ipXY",&track_ipXY);
    tt->SetBranchAddress("track_ipXYSig",&track_ipXYSig);
    tt->SetBranchAddress("track_ref_z",&track_ref_z);//analysis_20170523_v0
    tt->SetBranchAddress("track_nMissInnerHits",&track_nMissInnerHits);
    tt->SetBranchAddress("track_nMissInnerPxlLayers",&track_nMissInnerPxlLayers);
    tt->SetBranchAddress("track_nPxlLayers",&track_nPxlLayers);
    tt->SetBranchAddress("track_nHits",&track_nHits);
    tt->SetBranchAddress("track_ipZ",&track_ipZ);
    tt->SetBranchAddress("HLT_HT400",&hltTrig1d);
    tt->SetBranchAddress("HLT_HT500",&hltTrig1n);
    tt->SetBranchAddress("HLT_HT250",&hltTrig2d);
    tt->SetBranchAddress("HLT_HT350",&hltTrig2n);
    tt->SetBranchAddress("HLT_PFHT600",&hltTrig3d);
    //tt->SetBranchAddress("HLT_PFHT800",&hltTrig3n);//76, 80
    tt->SetBranchAddress("HLT_PFHT900",&hltTrig3n);//G,H

    /*
      tt->SetBranchAddress("vertex_index",&vertex_index);
      tt->SetBranchAddress("vertex_source",&vertex_source);
      tt->SetBranchAddress("vertex_z",&vertex_z);
    */

    // create a histograms
    TH1F *acount,*count;

    TH2F *btagEff_Den_b;
    TH2F *btagEff_Den_udsg;
    TH2F *btagEff_Num_b;
    TH2F *btagEff_Num_udsg;

    TH2F *btagEff_Den_b_all;
    TH2F *btagEff_Den_udsg_all;
    TH2F *btagEff_Num_b_all;
    TH2F *btagEff_Num_udsg_all;

    if(otfile) {
        TH1::SetDefaultSumw2();

        acount = new TH1F("acount","counts",20,0.,20.);
        count = new TH1F("count","counts",3,0,3);
        count->SetStats(0);
        count->SetCanExtend(TH1::kAllAxes);
        count->Fill("All",0);
        count->Fill("filter",0);
        count->Fill("4 jets",0);
        count->Fill("HT",0);
        count->Fill("jet pt1",0);
        count->Fill("jet pt2",0);
        count->Fill("jet pt3",0);
        count->Fill("jet pt4",0);
        count->Fill("MET",0);
        count->Fill("emerging",0);
        count->Fill("almostemerging",0);
        count->Fill("FakeRateBKG",0);

        //2d
        btagEff_Den_b_all     = new TH2F("btagEff_Den_b_all",   ";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
        btagEff_Den_udsg_all  = new TH2F("btagEff_Den_udsg_all",";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
        btagEff_Num_b_all     = new TH2F("btagEff_Num_b_all",   ";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
        btagEff_Num_udsg_all  = new TH2F("btagEff_Num_udsg_all",";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);

        btagEff_Den_b     = new TH2F("btagEff_Den_b",   ";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
        btagEff_Den_udsg  = new TH2F("btagEff_Den_udsg",";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
        btagEff_Num_b     = new TH2F("btagEff_Num_b",   ";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
        btagEff_Num_udsg  = new TH2F("btagEff_Num_udsg",";p_{T} [GeV];#eta", ptbinnum, ptbins, etabinnum, etabins);
    }

    //read all entries and fill the histograms
    Int_t nentries = (Int_t)tt->GetEntries();


//     double np0 = 0;
//     double np1 = 0;
//     double np2 = 0;
//     double np3 = 0;
    int nbTaggedTotAll = 0;//all jets
    int nNotbTagTotAll = 0;//all jets
    int nbTaggedTot = 0;//leading four jets
    int nNotbTagTot = 0;//leading four jets


    switch (ntagType) {
    case 0 : {NemergingCut=0; break;}
    case 1 : {NemergingCut=1; break;}
    case 12: {NemergingCut=1; break;}
    case 2 : {NemergingCut=2; break;}
    case 21: {NemergingCut=2; break;}
    case 22: {NemergingCut=2; break;}
    case 3 : {NemergingCut=3; break;}
    }


    //======================
    // Loop over events
    //======================
    for (Int_t i=0; i<nentries; i++) {
        int nbTaggedAll = 0;//# of all b-tagged jets
        int nbTagged = 0;//# of b-tagged jets of leading four jets
        int nZeroAlpha = 0;
        //std::cout<<"***event "<<event<<std::endl;
 
        if(!hasPre && otfile) eventCountPreTrigger->Fill(1);
    
        if(otfile) count->Fill("All",1);  // count number of events
        if(otfile) acount->Fill(0); // events passing JetFilter
        tt->GetEntry(i);

        // PV failure removal
        if (pv_index->at(0) != 0) continue;

        // PVZ cut
        float pv_z = pv_zv->at(0);
        if(fabs(pv_z)>15) continue;//analysis_20170523_v0 onward

        // Counting variables for PVTrackFraction
        int nTotGoodTrk = 0;
        int nGoodPVzTrk = 0;

        const int NNNjet = jet_index->size();
        // Note: we're only interested in events with at least four jets
        if(NNNjet<4) continue;

        // jets
        vector<double> jet_fnonPU(NNNjet);
        vector<double> jet_fmaxtrkpt(NNNjet);
        vector<double> jet_fsmallIPsig(NNNjet);
        vector<int> jet_ntrkpt1(NNNjet);
        vector<float> jet_alpha(NNNjet);
        vector<float> jet_meanip(NNNjet);
        vector<float> jet_meanipsig(NNNjet);
        vector<float> jet_logmeanipsig(NNNjet);
        vector<float> jet_medip(NNNjet);
        vector<float> jet_medipsig(NNNjet);
        vector<float> jet_logmedipsig(NNNjet);
        vector<float> jet_medtheta2D(NNNjet);
        vector<float> jet_logmedtheta2D(NNNjet);
        vector<float> r0(NNNjet);
        vector<float> r0sig(NNNjet);
        vector<float> r1(NNNjet);
        vector<int> jntrack(NNNjet);
        vector<float> jet_e(NNNjet);
        vector<float> jet_theta(NNNjet);
        vector<float> jet_px(NNNjet);
        vector<float> jet_py(NNNjet);
        vector<float> jet_pz(NNNjet);

        vector<int> jet_pid_maxEt(NNNjet);
        vector<float> jet_maxET_part(NNNjet);


        //======================
        // First loop over jets
        //======================
        for(Int_t j=0; j<NNNjet; j++) {
            //      std::cout<<"jet j = "<<j<<std::endl;
            jet_theta[j]=2.*atan(exp(-jet_eta->at(j)));
            jet_e[j]=jet_pt->at(j)/sin(jet_theta[j]);
            jet_px[j]=jet_pt->at(j)*cos(jet_phi->at(j));
            jet_py[j]=jet_pt->at(j)*sin(jet_phi->at(j));
            jet_pz[j]=jet_pt->at(j)/tan(jet_theta[j]);


            jet_ntrkpt1[j]=0;
            jet_meanip[j]=-1.;
            jet_logmeanipsig[j]=-1.;
            jet_medip[j]=-1.;
            jet_medipsig[j]=-1.;
            jet_logmedipsig[j]=-1.;
            jet_medtheta2D[j]=-1.;
            jet_logmedtheta2D[j]=-3.5;
            jet_alpha[j]=-1.;
            jet_fnonPU[j]=0.;
            jet_fmaxtrkpt[j]=0.;
            jet_fsmallIPsig[j]=0.;

            if(r0.size()>0) {r0[j]=-1.;r0sig[j]=-1.;}
            if(r1.size()>0) r1[j]=-1.;
            vector<float> track_pts = track_pt->at(j);
            vector<int> track_sources = track_source->at(j);
            vector<int> track_qualitys = track_quality->at(j);
            //vector<float> track_vertex_weights = track_vertex_weight->at(j);
            vector<float> track_pvWeights = track_pvWeight->at(j);
            vector<float> track_ipXYs = track_ipXY->at(j);
            vector<float> track_ipXYSigs = track_ipXYSig->at(j);
            vector<float> sort_ip(track_pts.size());
            vector<float> sort_ipsig(track_pts.size());
            for(uint it=0;it<track_pts.size();it++) sort_ip[it]=0;
            for(uint it=0;it<track_pts.size();it++) sort_ipsig[it]=0;
            vector<float> jet_trkip;
            vector<float> jet_trkipsig;
            vector<float> track_ref_zs = track_ref_z->at(j);//analysis_20170523_v0

            // jet_alpha
            if (varType==1) jet_alpha[j] = qcdtools->GetAlpha(track_pts,track_sources,track_qualitys,track_pvWeights,track_ref_zs,pv_z,pilecut2);
            else if (varType==2) {
                jet_alpha[j] = qcdtools->GetAlpha2Dsig(track_pts,track_sources,track_qualitys,track_ipXYSigs,track_ref_zs,pv_z,pilecut2);
            }
            else if (varType==3) {
                jet_alpha[j] = qcdtools->GetAlpha3Dsig(track_pts,track_sources,track_qualitys,track_ipXYSigs,track_ref_zs,pv_z,pilecut2,sigzCut);
            }
            else {
                std::cout << "[Warning] varType not defined! Default alpha3Dsig is used!" << std::endl;
                jet_alpha[j] = qcdtools->GetAlpha3Dsig(track_pts,track_sources,track_qualitys,track_ipXYSigs,track_ref_zs,pv_z);
            }

            if (jet_alpha[j]==0) nZeroAlpha++;
            jntrack[j]=0;
            double sumptallnz=0.;
            double sumnonPU=0.;
            double sumsmallIPsig=0.;
            double ptmaxtrk=0.;

            //===================================
            // Loop over tracks of first jet loop
            //===================================
            for (unsigned itrack=0; itrack<track_pts.size(); itrack++) {
                if(track_sources[itrack]==0 && ((track_qualitys[itrack] & 4) > 0)) {
                    sumptallnz+=track_pts[itrack];

                    // PVTrackFraction use tracks without pilecut
                    nTotGoodTrk++;//Count good tracks for PVTrackFraction
                    if (fabs(pv_z-track_ref_zs[itrack])<pvztrkcut) nGoodPVzTrk++;//Count good tracks passing pvztkcut for PVTrackFraction

                    // pileup cut
                    if (fabs(pv_z-track_ref_zs[itrack])>pilecut) continue;// remove tracks with exceedingly large z
                    if (fabs(pv_z-track_ref_zs[itrack])<pilecut2) sumnonPU+=track_pts[itrack];
                    if (fabs(track_ipXYSigs[itrack])<ipXYsigcut) sumsmallIPsig+=track_pts[itrack];

                    if(track_pts[itrack]>ptmaxtrk) {
                        ptmaxtrk=track_pts[itrack];
                    }
                    sort_ip[jntrack[j]]=fabs(track_ipXYs[itrack]);
                    sort_ipsig[jntrack[j]]=fabs(track_ipXYSigs[itrack]);
                    //  std::cout<<"track vertex weight is "<<track_vertex_weights[itrack]<<std::endl;
                    if(track_pts[itrack]>1) jet_ntrkpt1[j]+=1;
                    //  std::cout<<" track "<<itrack<<" ip "<<track_ipXYs[itrack]<<" mean ip "<<jet_meanip[j]<<std::endl;
                    jet_meanip[j]=jet_meanip[j]+fabs(track_ipXYs[itrack]);
                    jet_meanipsig[j]=jet_meanipsig[j]+fabs(track_ipXYSigs[itrack]);
                    jet_logmeanipsig[j]=jet_logmeanipsig[j]+fabs(track_ipXYSigs[itrack]);
                    jet_trkip.push_back(fabs(track_ipXYs[itrack]));
                    jet_trkipsig.push_back(fabs(track_ipXYSigs[itrack]));
                    jntrack[j]++;
                }
            }
            //=======================================
            // End loop over tracks of first jet loop
            //=======================================

            float atmp = jntrack[j];
            if(jntrack[j]>0) {
                jet_meanip[j]=jet_meanip[j]/atmp;
                jet_logmeanipsig[j]=jet_logmeanipsig[j]/atmp;
                jet_logmeanipsig[j]=log10(jet_logmeanipsig[j]);

                // median
                jet_medip[j] = CalcMedian(jet_trkip);
                jet_medipsig[j] = CalcMedian(jet_trkipsig);
                jet_logmedipsig[j] = log10(jet_medipsig[j]);
                jet_medtheta2D[j] = jet_theta2D->at(j);
                jet_logmedtheta2D[j] = (jet_medtheta2D[j]==-1 ? -3.5 : log10(jet_theta2D->at(j)));
            }
            if(sumptallnz>0) jet_fnonPU[j]=sumnonPU/sumptallnz;//analysis_20170523_v0
            if(sumnonPU>0) jet_fsmallIPsig[j]=sumsmallIPsig/sumnonPU;//analysis_20170523_v0
            jet_fmaxtrkpt[j]=ptmaxtrk/jet_pt->at(j);//max trk pt/jet pt//analysis_20170523_v0

            std::sort(sort_ip.begin(), sort_ip.end(), std::greater<float>());
            if(sort_ip.size()>0) r0[j]=sort_ip[0];
            if(sort_ip.size()>1) r1[j]=sort_ip[1];
            std::sort(sort_ipsig.begin(), sort_ipsig.end(), std::greater<float>());
            if(sort_ipsig.size()>0) r0sig[j]=sort_ipsig[0];
            //      std::cout<<"mean max are "<<jet_meanip[j]<<" "<<r0[j]<<std::endl;

            //===================================
            // Jet flavor id
            //===================================
            jet_pid_maxEt[j]=0;
            jet_maxET_part[j]=0;

            if (!isData) {
                // calculate some gen particle information for jet
                int NNNgp = gp_index->size();
                int igenmax=-1;
                float etgenmax=0.;
                for(Int_t igen=1; igen<NNNgp; igen++) {
                    if((abs(gp_pdgId->at(igen))<6)||(abs(gp_pdgId->at(igen))==21)) {  // quark or gluon
                        if(DeltaR1(jet_eta->at(j),jet_phi->at(j),gp_eta->at(igen),gp_phi->at(igen))<0.4) {
                            if(gp_pt->at(igen)>etgenmax) {
                                igenmax=igen;
                                etgenmax=gp_pt->at(igen);
                            }
                        }
                    }
                }
                // fix glue to bbbar
                float igenmax2=-1;
                float etgenmax2=0.;
                if(igenmax>0) {
                    if(abs(gp_pdgId->at(igenmax))==21) {
                        for(Int_t igen=1; igen<NNNgp; igen++) {
                            if((abs(gp_pdgId->at(igen))==5)&&(gp_pt->at(igen)>10.)) {  // b
                                if(DeltaR1(jet_eta->at(j),jet_phi->at(j),gp_eta->at(igen),gp_phi->at(igen))<0.4) {
                                    if(gp_pt->at(igen)>etgenmax2) {
                                        igenmax2=1;
                                        etgenmax2=gp_pt->at(igen);
                                    }
                                }
                            }
                        }
                    }
                }

                if(igenmax>-1) {
                    int ipid = gp_pdgId->at(igenmax);
                    if(abs(ipid)<6) {
                        jet_pid_maxEt[j]=gp_pdgId->at(igenmax);
                        jet_maxET_part[j] = etgenmax;
                        
                    } else {
                        if(igenmax2==-1) {
                            jet_pid_maxEt[j]=7;
                            jet_maxET_part[j] = etgenmax;
                        } else {//g->bb
                            jet_pid_maxEt[j]=8;
                            jet_maxET_part[j] = etgenmax;

                        }
                    }
                } // end calculate some gen particle information for jet
            }//end of MC truth only block
            if(jet_csv->at(j) >= bTagWP) {
                if (isData) jet_pid_maxEt[j]=5;
                nbTaggedTotAll++;
                nbTaggedAll++;
                //std::cout << "Jet b-tagged." << std::endl;
            }
            else {
                if (isData) jet_pid_maxEt[j]=0;
                nNotbTagTotAll++;
                //std::cout << "Jet not b-tagged." << std::endl;
            }
        }
        //===================================
        // End of first loop over jets
        //===================================


        float PVTrackFraction = (float)nGoodPVzTrk/(float)nTotGoodTrk;
        //std::cout <<"PVTrackFraction = " << PVTrackFraction << std::endl;

        //now see which jets are emerging
        //    std::cout<<" in event "<<event<<" number of jets is "<<NNNjet<<std::endl;
        vector<bool> emerging(NNNjet);
        vector<bool> almostemerging(NNNjet);
        vector<bool> basicjet(NNNjet);
        for( int i=0;i<NNNjet;i++) {
            emerging[i]=false;
            almostemerging[i]=false;
            basicjet[i]=false;
        }
        int nemerging=0;
        int nalmostemerging=0;


        //===================================
        // Second loop over jets
        // Jet selection
        //===================================
        for(int ij=0;ij<NNNjet;ij++) {
            vector<int> track_qualitys = track_quality->at(ij);
            vector<float> track_ipXYs = track_ipXY->at(ij);
            vector<float> track_ipXYSigs = track_ipXYSig->at(ij);
            vector<int> track_sources = track_source->at(ij);
            //vector<float> track_vertex_weights = track_vertex_weight->at(ij);
            vector<float> track_pvWeights = track_pvWeight->at(ij);
            vector<float> track_ref_zs = track_ref_z->at(ij);//analysis_20170523_v0

            if(fabs(jet_eta->at(ij))<jetacut) { // jet eta cut
                if(jet_nef->at(ij)<NemfracCut) {  // neutral fraction
                    if(jet_ntrkpt1[ij]>ntrk1cut) {  // tracks pt>1
                        if(jet_cef->at(ij)<CemfracCut) {  //charged fraction
                            if(jet_fmaxtrkpt[ij]>0.6) continue;//analysis_20170523_v0
                            //basicjet[ij]=true;
                            if(ij<4) {
                                basicjet[ij]=true;
                                // # of btagged for leading 4 jets
                                if(jet_csv->at(ij) >= bTagWP) {
                                    nbTaggedTot++;
                                    nbTagged++;
                                    //std::cout << "Jet b-tagged." << std::endl;
                                }
                                else {
                                    nNotbTagTot++;
                                    //std::cout << "Jet not b-tagged." << std::endl;
                                }

                                // btag eff of all basic jets
                                if (jet_pid_maxEt[ij]==5 || jet_pid_maxEt[ij]==8) {
                                    btagEff_Den_b_all->Fill(jet_pt->at(ij),jet_eta->at(ij));
                                    if(jet_csv->at(ij) >= bTagWP) {
                                        btagEff_Num_b_all->Fill(jet_pt->at(ij),jet_eta->at(ij));
                                    }
                                }
                                else {
                                    btagEff_Den_udsg_all->Fill(jet_pt->at(ij),jet_eta->at(ij));
                                    if(jet_csv->at(ij) >= bTagWP) {
                                        btagEff_Num_udsg_all->Fill(jet_pt->at(ij),jet_eta->at(ij));
                                    }
                                }
                                // end of btag eff of all basic jets

                            }
                            //if(jet_alpha[ij]<alphaMaxcut) { // alpha max
                            if(jet_alpha[ij]<alphaMaxcut && jet_alpha[ij]>-1) { // alpha max
                                almostemerging[ij]=true;

                                // uncomment if count only leading jets for event selection later
                                if(ij<4)
                                    nalmostemerging+=1;
                                //if(r0[ij]>maxIPcut) { // max IP cut
                                //if(jet_medip[ij]>maxIPcut) { // med IP cut
                                if(jet_medip[ij]>maxIPcut && jet_medtheta2D[ij]>0) { // med IP cut
                                    emerging[ij]=true;

                                    // uncomment if count only leading jets for event selection later
                                    if(ij<4)
                                        nemerging+=1;
                                    if(jet_meanip[ij]>r0[ij]) std::cout<<"DANGER DANGER"<<std::endl;
                                }//maxIPcut
                            }//alphaMaxCut
                        }//CemfractCut
                    }//ntrk1cut
                }//NemfracCut
            }//jet eta cut
        }
        //===================================
        // End of second loop over jets
        //===================================


        // *************************************************************
        // now start the event selection preparation
        // *************************************************************

        if(otfile) count->Fill("filter",1);
        if(otfile) acount->Fill(1);

        if (PVTrackFraction<=0.1) continue;

        // require at least 4 jets
        bool C4jet=true;
        int nemgGoodjet = 0;
        int nalemgGoodjet = 0;
        vector<int> goodjetIdx;
        //for(int nj=0;nj<NNNjet;nj++) {
        for(int nj=0;nj<4;nj++) {
            if (!basicjet[nj] || jet_pt->at(nj)<minJetPt) continue;//comment out this line for leading four jets
            goodjetIdx.push_back(nj);
            //std::cout << "Idx[" << nj <<"] is good jet" << std::endl;
            if (emerging[nj]) nemgGoodjet+=1;
            if (almostemerging[nj]) nalemgGoodjet+=1;
        }

        if(goodjetIdx.size()!=4) {
            C4jet=false;
            continue;
        }

        // HT
        double HT = jet_pt->at(0)+jet_pt->at(1)+jet_pt->at(2)+jet_pt->at(3);

        bool HLT=false;
        if (hltTrig3n) HLT=true;

        bool CHT=true;
        if(HT<HTcut) CHT=false;
        // jet pt
        bool Cpt1=false;
        bool Cpt2=false;
        bool Cpt3=false;
        bool Cpt4=false;
        if((jet_pt->at(0)>pt1cut)&&(fabs(jet_eta->at(0))<jetacut)) Cpt1=true;
        if((jet_pt->at(1)>pt2cut)&&(fabs(jet_eta->at(1))<jetacut)) Cpt2=true;
        if((jet_pt->at(2)>pt3cut)&&(fabs(jet_eta->at(2))<jetacut)) Cpt3=true;
        if((jet_pt->at(3)>pt4cut)&&(fabs(jet_eta->at(3))<jetacut)) Cpt4=true;

        // number emerging jets
//         bool Cnem = true;
//         if(nemerging<NemergingCut) Cnem=false;

//         bool Canem =true;
        //if(nalmostemerging>=4) Canem=false;
        //if(nalemgGoodjet>=4) Canem=false;

        bool Cmet = false;
        if(met_pt>METcut) Cmet = true;

        //blind
//         if(blind) {
//             Cnem=false;
//             //Canem=false;
//         }
        // *************************************************************
        // End of the event selection preparation
        // *************************************************************


        // *************************************************************
        // apply event selection cuts sequentially
        // *************************************************************

        //if ( !HLT || !CHT ) continue;
        //if ( !HLT || !C4jet || !CHT || !Cpt1 || !Cpt2 || !Cpt3 || !Cpt4 ) continue;
        if ( !HLT || !C4jet || !CHT || !Cpt1 || !Cpt2 || !Cpt3 || !Cpt4 || !Cmet) continue;

        //===================================
        // Third loop over jets
        // Btagging efficiency
        //===================================
        for(int ij=0;ij<4;ij++) {
            // btagging efficiency
            if (jet_pid_maxEt[ij]==5 || jet_pid_maxEt[ij]==8) {
                btagEff_Den_b->Fill(jet_pt->at(ij),jet_eta->at(ij));
                if(jet_csv->at(ij) >= bTagWP) {
                    btagEff_Num_b->Fill(jet_pt->at(ij),jet_eta->at(ij));
                }
            }
            else {
                btagEff_Den_udsg->Fill(jet_pt->at(ij),jet_eta->at(ij));
                if(jet_csv->at(ij) >= bTagWP) {
                    btagEff_Num_udsg->Fill(jet_pt->at(ij),jet_eta->at(ij));
                }
            }
            // end btagging efficiency
        }


    }// end of loop over events
    // *************************************************************
    // End of loop over events
    // *************************************************************

    std::cout << "Total # btagged = " << nbTaggedTot << std::endl;
    std::cout << "Total # not btagged = " << nNotbTagTot << std::endl;
    std::cout << "Total # btagged (ALL) = " << nbTaggedTotAll << std::endl;
    std::cout << "Total # not btagged (ALL) = " << nNotbTagTotAll << std::endl;

    if(otfile) {
        TFile myfile(outputfilename,"RECREATE");
        count->LabelsDeflate();
        count->LabelsOption("v");
        //  count->LabelsOption("a");

        eventCountPreTrigger->Write();
        acount->Write();
        count->Write();

        //2d
        btagEff_Den_b->Write();
        btagEff_Den_udsg->Write();
        btagEff_Num_b->Write();
        btagEff_Num_udsg->Write();

        btagEff_Den_b_all->Write();
        btagEff_Den_udsg_all->Write();
        btagEff_Num_b_all->Write();
        btagEff_Num_udsg_all->Write();

        myfile.Close();
    }

    tt->ResetBranchAddresses();
  
    delete jet_index;
    delete jet_source;
    delete jet_pt;
    delete jet_eta;
    delete jet_phi;
    delete jet_alphaMax;
    delete jet_cef;
    delete jet_nef;
    delete jet_chf;
    delete jet_theta2D;
    //  delete jet_phf;
    delete jet_csv;
    delete track_pt;
    delete track_eta;
    delete track_source;
    delete track_index;
    delete track_jet_index;
    delete track_vertex_index;
    delete track_algo;
    delete track_quality;
    delete track_vertex_weight;
    delete track_pvWeight;
    delete track_ipZ;
    delete track_ipXY;
    delete track_ipXYSig;
    delete qcdtools;


    f->Close();
  


    return npass;
}
